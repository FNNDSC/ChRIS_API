#!/usr/bin/env python

# -*- coding: utf-8 -*-
"""

 _____ _    ______ _____ _____   _   _ _ _
/  __ \ |   | ___ \_   _/  ___| | | | | | |
| /  \/ |__ | |_/ / | | \ `--.  | | | | | |_ _ __ ___  _ __
| |   | '_ \|    /  | |  `--. \ | | | | | __| '__/ _ \| '_ \
| \__/\ | | | |\ \ _| |_/\__/ / | |_| | | |_| | | (_) | | | |
 \____/_| |_\_| \_|\___/\____/   \___/|_|\__|_|  \___/|_| |_|



font generated by:
http://patorjk.com/software/taag/#p=display&f=Doom&t=ChRIS%20Ultron

ChRIS_SM

'ChRIS_SM' is the 'ChRIS Simulated Machine' or 'ChRIS Simple Machine'
or ... :-) -- basically it is a simplified infrastructure for
developing / testing the API between the front end view and various
back-end services.

Essentially, 'ChRIS_SM' simulates the API behaviour on a synthetic
instance of ChRIS consisting of a single user (with password) and
a few feeds containing different data, views, results, notes, etc.


"""

from __future__ import print_function

import abc
import hashlib
import argparse
import os
import sys
import datetime


import C_snode
import message
import feed
import ChRIS_RPCAPI

class ChRIS_SMUserDB(object):
    """A "DB" of users and passwords.

    """

    def DB_build(self):
        s               = self._stree
        s.cd('/')
        s.mkcd('users')
        s.mkcd('chris')
        s.touch("userName",     "chris")
        s.touch("fullName",     "ChRIS User")
        s.touch("passwd",       "chris1234")
        s.mknode(['feed'])
        s.mkcd('login')

    def user_checkAPIcanCall(self, **kwargs):
        """Authenticates (or not) the current call to the API
        """
        s                   = self._stree
        astr_user           = ""
        astr_sessionHash    = ""
        for key, value in kwargs.iteritems():
            if key == 'user':           astr_user           = value
            if key == 'callHash':       astr_sessionHash    = value
        if not s.cd('/users/%s/login' % (astr_user)):       return False
        d_activeSessionInfo     = s.cat('activeSessionInfo')
        # print("**********")
        # print(d_activeSessionInfo)
        if not s.cd(d_activeSessionInfo['login']): return False

        d_currentSessionInfo    = s.cat(d_activeSessionInfo['session'])
        # print(d_currentSessionInfo)
        if not d_currentSessionInfo['loginStatus']:         return False
        str_sessionToken        = d_currentSessionInfo['sessionToken']
        str_sessionSeed         = d_currentSessionInfo['sessionSeed']
        str_hashInput           = '%s%s' % (str_sessionToken, str_sessionSeed)
        str_sessionHash         = self._md5.md5(str_hashInput).hexdigest()
        b_OK                    = (str_sessionHash == astr_sessionHash)
        if b_OK:
            d_currentSessionInfo['sessionToken']    = str_hashInput
            d_currentSessionInfo['sessionSeed']     = int(str_sessionSeed) + 1
        d_currentSessionInfo['APIcanCall']      = b_OK
        self.user_updateSessionInfo(sessionInfo = d_currentSessionInfo, **kwargs)
        return b_OK

    def user_getAuthInfo(self, **kwargs):
        """Gets the DB auth info of the user
        """
        s                   = self._stree

        for key,value in kwargs.iteritems():
            if key == 'user':           str_user            = value
        s.cd('/users/%s/login' % str_user)
        d_activeSessionInfo = s.cat('activeSessionInfo')
        if not s.cd(d_activeSessionInfo['login']):          return False
        d_authSession   = s.cat(d_activeSessionInfo['session'])
        rd_authInfo     = {}
        rd_authInfo['sessionStatus']    = d_authSession['sessionStatus']
        rd_authInfo['sessionSeed']      = d_authSession['sessionSeed']
        return rd_authInfo

    def user_getSessionInfo(self, **kwargs):
        """Gets the DB session entry of the user
        """
        s                   = self._stree

        for key,value in kwargs.iteritems():
            if key == 'user':           str_user            = value
        s.cd('/users/%s/login' % str_user)
        d_activeSessionInfo = s.cat('activeSessionInfo')
        if not s.cd(d_activeSessionInfo['login']):          return False
        return s.cat(d_activeSessionInfo['session'])

    def user_updateSessionInfo(self, **kwargs):
        """Updates the DB entry of the user
        """
        s                   = self._stree
        b_createSession     = False

        for key,value in kwargs.iteritems():
            if key == 'user':           str_user            = value
            if key == 'sessionInfo':    dict_sessionInfo    = value
            if key == 'createSession':  b_createSession     = value
        a = dict_sessionInfo
        s.cd('/users/%s/login' % str_user)
        if b_createSession:
            s.mknode([a['loginTimeStamp']])
            d_sessionLookup = {'login' : a['loginTimeStamp'], 'session' : a['sessionToken']}
            s.touch('activeSessionInfo', d_sessionLookup)
        if not s.cd(a['loginTimeStamp']): return False
        s.touch(a['sessionToken'], a)
        return True

    def user_login(self, **kwargs):
        """Log a user in.

        This method "logs" a user in, using the passwd.

        It also updates the DB user/session entry accordingly, and creates the
        "tree" of feeds for that user.

        Args (kwargs):
            user (string): The user to login.
            passwd (string): The user passwd.

        Returns:
            adict (dictionary): dictionary of login and session info.

        """

        for key, val in kwargs.iteritems():
            if key == 'user':   astr_user   = val
            if key == 'passwd': astr_passwd = val

        # login/session/canCall structure
        ret                     = {}
        now                     = datetime.datetime.today()
        ret['loginTimeStamp']   = now.strftime('%Y-%m-%d_%H:%M:%S.%f')
        ret['loginStatus']      = False
        ret['loginMessage']     = ""
        ret['logoutMessage']    = ""
        ret['sessionStatus']    = False
        ret['sessionToken']     = "ABCDEF"
        ret['sessionSeed']      = "1"
        ret['APIcanCall']       = False

        s = self._stree
        s.cdnode('/users')
        if not s.cdnode(astr_user):
            ret['loginMessage']     = 'User not found in database.'
        else:
            if s.cat('passwd') != astr_passwd:
                ret['loginMessage']     = 'Incorrect password.'
            else:
                ret['loginStatus']      = True
                ret['loginMessage']     = 'Successful login at %s.' % datetime.datetime.now()
                ret['logoutMessage']    = ""
                ret['sessionStatus']    = True
                ret['sessionToken']     = "ABCDEF"
                ret['sessionSeed']      = "1"

                # Get the user's feed tree structure
                feedTree                = feed.FeedTree_chrisUser()
                # and attach it to the stree of this object
                s.cd('/users/%s/feed' % astr_user)
                s.touch('tree', feedTree)
                self._userTree          = feedTree

        self.user_updateSessionInfo(sessionInfo = ret, createSession = True, **kwargs)
        return ret

    def __init__(self):
        self._md5       = hashlib
        self._stree     = C_snode.C_stree()
        self._userTree  = None
        self.DB_build()

class ChRIS_SMCore(object):
    """The ChRIS_SM core

    """

    __metaclass__   = abc.ABCMeta

    def __init__(self, **kwargs):
        self.s_tree     = C_snode.C_stree()
        self._userDB    = ChRIS_SMUserDB()

    def login(self, **kwargs):
        return(self._userDB.user_login(**kwargs))

class ChRIS_SM(object):
    """The ChRIS Simulated Machine


    """

    #
    # Class member variables -- if declared here are shared
    # across all instances of this class
    #
    _dictErr = {
        'subjectSpecFail'   : {
            'action'        : 'examining command line arguments, ',
            'error'         : 'it seems that no subjects were specified.',
            'exitCode'      : 10},
        'no_apiCall'   : {
            'action'        : 'examining command line arguemnts, ',
            'error'         : 'it seems that the required --apiCall is missing.',
            'exitCode'      : 11},
        'no_stateFile'   : {
            'action'        : 'examining command line arguemnts, ',
            'error'         : 'it seems that the required --stateFile is missing.',
            'exitCode'      : 12},
        'no_stateFileExist': {
            'action'        : 'checking on the <stateFile>, ',
            'error'         : 'a system error was encountered. Does the <stateFile> exist?',
            'exitCode'      : 20},
        'no_stateFileAccess': {
            'action'        : 'attempting to access the <stateFile>, ',
            'error'         : 'a system error was encountered. Does the <stateFile> exist?',
            'exitCode'      : 21},
        'no_authModuleSpec' : {
            'action'        : 'attempting to parse the API call, ',
            'error'         : 'the auth module was not specified',
            'exitCode'      : 30},
    }

    __metaclass__   = abc.ABCMeta

    def log(self, *args):
        '''
        get/set the internal pipeline log message object.

        Caller can further manipulate the log object with object-specific
        calls.
        '''
        if len(args):
            self._log = args[0]
        else:
            return self._log

    def name(self, *args):
        '''
        get/set the descriptive name text of this object.
        '''
        if len(args):
            self.__name = args[0]
        else:
            return self.__name


    def __init__(self, **kwargs):
        """The CHRIS_SM constructor.

        """

        self.__name                     = "ChRIS_SM"

        self._feedTree                  = C_snode.C_stree()
        self._SMCore                    = ChRIS_SMCore()
        self._name                      = ""
        self._log                       = message.Message()
        self._log.tee(True)
        self._log.syslog(True)

        # Convenience members
        self.DB                         = self._SMCore._userDB
        self.homePage                   = None

    @property
    def feedTree(self):
        """STree Getter"""
        return self._feedTree

    @feedTree.setter
    def feedTree(self, value):
        """STree Getter"""
        self._feedTree = value

    def login(self, **kwargs):
        loginStatus     = self._SMCore.login(**kwargs)
        self.homePage   = self._SMCore._userDB._userTree
        return(loginStatus)

    def feed_nextID(self):
        """Find the next ID in the Feed database

        Returns:
            nextID (string): The next ID to use for a Feed.
        """

class ChRIS_SM_RPC(ChRIS_SM):
    """The ChRIS_SM_RPC subclass implements a ChRIS_SM using an RPC type API paradigm.


    """

    def __init__(self, **kwargs):
        """Constructor.

        This essentially calls up the chain to the base constructor

        Args:

        """
        ChRIS_SM.__init__(self, **kwargs)

        self.API    = ChRIS_RPCAPI.ChRIS_RPCAPI(**kwargs)


class ChRIS_authenticate(object):
    """The ChRIS_authenticate object is responsible for authenticated valid
        access to the API

        This method is the main "gatekeeper" between external API
        calls and actual methods in ChRIS system. It serves as a
        central entry point for each call so that user token
        authentication can be verified, as well as any additional
        parsing on the actual attempt to exec code.

        Since this method calls the passed "function" without regard for
        scope, the called object must actually exist at the scope at which
        this auth is being wrapped.

    """

    def __init__(self, achris_instance, aself_name):
        """Constructor.

        Builds a ChRIS_authenticate object. This object acts as a functor that calls
        into a ChRIS object after checking the authentication of the caller.

        Args:
            achris_instance (ChRIS):    the chris instance to authenticate against
            aself_name (string):        this object's string name
        """
        self.chris          = achris_instance
        self._name          = aself_name

    def __call__(self, f, **kwargs):
        """Call the object/method

        This functor actually wraps around the call, and is the main entry point to
        calling ANYTHING from ChRIS. It is here where the authentication of the
        caller/hash is verified before executing the actual object.method call

        Args:
            f (object.method):  The object.method to call.

        Returns:
            Whatever is returned by the call is returned back.
        """
        #print("In auth.__call__()")

        str_user    = ""
        str_hash    = ""
        for key,value in kwargs.iteritems():
            if key == 'user':       str_user    = value
            if key == 'hash':       str_hash    = value

        db = self.chris._SMCore._userDB
        db.user_checkAPIcanCall(**kwargs)
        return f()


def warn(*objs):
    print("WARNING: ", *objs, file=sys.stderr)

def synopsis(ab_shortOnly = False):
    scriptName = os.path.basename(sys.argv[0])
    shortSynopsis =  '''
    SYNOPSIS

            %s                                     \\
                            [--stateFile <stateFile>]       \\
                            --APIcall <apiCall>


    ''' % scriptName

    description =  '''
    DESCRIPTION

        `%s' simulates a ChRIS machine, and specifically the
        web service interface to the machine.

    ARGS

       --stateFile <stateFile> (required for RPC-type calling)
       The file that tracks calls pertinent to a specific session.
       API calls are logged to <stateFile> and replayed back when
       ChRIS_SM is instantiated. In this manner the machine state
       can be rebuilt. The current <apiCall> is appended to the
       <stateFile>.

       --apiCall <apiCall> (required)
       The actual API call to make.

    EXAMPLES


    ''' % (scriptName)
    if ab_shortOnly:
        return shortSynopsis
    else:
        return shortSynopsis + description


if __name__ == "__main__":
    """Simulated session interacting with the ChRIS_SM

    Once logged in, the client and service use a hash to authenticate.
    Essentially, on first login, the system returns a token to the client
    and an initial seed. The client hashes the token and seed when
    communicating with the service. For each communication, the service
    returns a new seed that must be used in the next comms.

    State is preserved in the SM by tracking all "api" calls  to a
    stateful file, and replaying them in order on subsequent runs.
    The current "api" call is appended to this stateful file.

    """

    if len(sys.argv) == 1:
        print(synopsis())
        sys.exit(1)

    parser      = argparse.ArgumentParser(description = synopsis(True))
    parser.add_argument(
        '-s', '--stateFile',
        help    =   "The <stateFile> keeps track of ChRIS state for RPC-type calling regimes.",
        dest    =   'str_stateFileName',
        action  =   'store',
        default =   "<void>"
    )
    parser.add_argument(
        '-a', '--APIcall',
        help    =   "The actual API call to make.",
        dest    =   'str_apiCall',
        action  =   'store',
        default =   "<void>"
    )

    args            = parser.parse_args()
    chris           = ChRIS_SM_RPC(stateFile   = args.str_stateFileName)
    chris.API.auth  = ChRIS_authenticate(chris, 'auth')
    chris.API(APIcall = args.str_apiCall)
