#!/usr/bin/env python

# -*- coding: utf-8 -*-
"""

 _____ _    ______ _____ _____   _   _ _ _
/  __ \ |   | ___ \_   _/  ___| | | | | | |
| /  \/ |__ | |_/ / | | \ `--.  | | | | | |_ _ __ ___  _ __
| |   | '_ \|    /  | |  `--. \ | | | | | __| '__/ _ \| '_ \
| \__/\ | | | |\ \ _| |_/\__/ / | |_| | | |_| | | (_) | | | |
 \____/_| |_\_| \_|\___/\____/   \___/|_|\__|_|  \___/|_| |_|



font generated by:
http://patorjk.com/software/taag/#p=display&f=Doom&t=ChRIS%20Ultron

ChRIS_SM

'ChRIS_SM' is the 'ChRIS Simulated Machine' or 'ChRIS Simple Machine'
or ... :-) -- basically it is a simplified infrastructure for
developing / testing the API between the front end view and various
back-end services.

Essentially, 'ChRIS_SM' simulates the API behaviour on a synthetic
instance of ChRIS consisting of a single user (with password) and
a few feeds containing different data, views, results, notes, etc.


"""

from __future__ import print_function

import abc
import json
import hashlib
import argparse
import os
import sys
import time
import datetime

from urlparse import urlparse, parse_qs
import shlex
import C_snode
import error
import message
import feed

class ChRIS_SMUserDB(object):
    """A "DB" of users and passwords.

    """

    def DB_build(self):
        s               = self._stree
        s.cd('/')
        s.mkcd('users')
        s.mkcd('chris')
        s.touch("userName",     "chris")
        s.touch("fullName",     "ChRIS User")
        s.touch("passwd",       "chris1234")
        s.mknode(['feed'])
        s.mkcd('login')

    def user_checkAPIcanCall(self, **kwargs):
        """Authenticates (or not) the current call to the API
        """
        s                   = self._stree
        astr_user           = ""
        astr_sessionHash    = ""
        for key, value in kwargs.iteritems():
            if key == 'user':           astr_user           = value
            if key == 'callHash':       astr_sessionHash    = value
        if not s.cd('/users/%s/login' % (astr_user)):       return False
        d_activeSessionInfo     = s.cat('activeSessionInfo')
        # print("**********")
        # print(d_activeSessionInfo)
        if not s.cd(d_activeSessionInfo['login']): return False

        d_currentSessionInfo    = s.cat(d_activeSessionInfo['session'])
        # print(d_currentSessionInfo)
        if not d_currentSessionInfo['loginStatus']:         return False
        str_sessionToken        = d_currentSessionInfo['sessionToken']
        str_sessionSeed         = d_currentSessionInfo['sessionSeed']
        str_hashInput           = '%s%s' % (str_sessionToken, str_sessionSeed)
        str_sessionHash         = self._md5.md5(str_hashInput).hexdigest()
        b_OK                    = (str_sessionHash == astr_sessionHash)
        if b_OK:
            d_currentSessionInfo['sessionToken']    = str_hashInput
            d_currentSessionInfo['sessionSeed']     = int(str_sessionSeed) + 1
        d_currentSessionInfo['APIcanCall']      = b_OK
        self.user_updateSessionInfo(sessionInfo = d_currentSessionInfo, **kwargs)
        return b_OK

    def user_getAuthInfo(self, **kwargs):
        """Gets the DB auth info of the user
        """
        s                   = self._stree

        for key,value in kwargs.iteritems():
            if key == 'user':           str_user            = value
        s.cd('/users/%s/login' % str_user)
        d_activeSessionInfo = s.cat('activeSessionInfo')
        if not s.cd(d_activeSessionInfo['login']):          return False
        d_authSession   = s.cat(d_activeSessionInfo['session'])
        rd_authInfo     = {}
        rd_authInfo['sessionStatus']    = d_authSession['sessionStatus']
        rd_authInfo['sessionSeed']      = d_authSession['sessionSeed']
        return rd_authInfo

    def user_getSessionInfo(self, **kwargs):
        """Gets the DB session entry of the user
        """
        s                   = self._stree

        for key,value in kwargs.iteritems():
            if key == 'user':           str_user            = value
        s.cd('/users/%s/login' % str_user)
        d_activeSessionInfo = s.cat('activeSessionInfo')
        if not s.cd(d_activeSessionInfo['login']):          return False
        return s.cat(d_activeSessionInfo['session'])

    def user_updateSessionInfo(self, **kwargs):
        """Updates the DB entry of the user
        """
        s                   = self._stree
        b_createSession     = False

        for key,value in kwargs.iteritems():
            if key == 'user':           str_user            = value
            if key == 'sessionInfo':    dict_sessionInfo    = value
            if key == 'createSession':  b_createSession     = value
        a = dict_sessionInfo
        s.cd('/users/%s/login' % str_user)
        if b_createSession:
            s.mknode([a['loginTimeStamp']])
            d_sessionLookup = {'login' : a['loginTimeStamp'], 'session' : a['sessionToken']}
            s.touch('activeSessionInfo', d_sessionLookup)
        if not s.cd(a['loginTimeStamp']): return False
        s.touch(a['sessionToken'], a)
        return True

    def user_login(self, **kwargs):
        """Log a user in.

        This method "logs" a user in, using the passwd.

        It also updates the DB user/session entry accordingly, and creates the
        "tree" of feeds for that user.

        Args (kwargs):
            user (string): The user to login.
            passwd (string): The user passwd.

        Returns:
            adict (dictionary): dictionary of login and session info.

        """

        for key, val in kwargs.iteritems():
            if key == 'user':   astr_user   = val
            if key == 'passwd': astr_passwd = val

        # login/session/canCall structure
        ret                     = {}
        now                     = datetime.datetime.today()
        ret['loginTimeStamp']   = now.strftime('%Y-%m-%d_%H:%M:%S.%f')
        ret['loginStatus']      = False
        ret['loginMessage']     = ""
        ret['logoutMessage']    = ""
        ret['sessionStatus']    = False
        ret['sessionToken']     = "ABCDEF"
        ret['sessionSeed']      = "1"
        ret['APIcanCall']       = False

        s = self._stree
        s.cdnode('/users')
        if not s.cdnode(astr_user):
            ret['loginMessage']     = 'User not found in database.'
        else:
            if s.cat('passwd') != astr_passwd:
                ret['loginMessage']     = 'Incorrect password.'
            else:
                ret['loginStatus']      = True
                ret['loginMessage']     = 'Successful login at %s.' % datetime.datetime.now()
                ret['logoutMessage']    = ""
                ret['sessionStatus']    = True
                ret['sessionToken']     = "ABCDEF"
                ret['sessionSeed']      = "1"
                feedTree                = feed.FeedTree_chrisUser()
                s.cd('/users/%s/feed' % astr_user)
                s.touch('tree', feedTree)
        self.user_updateSessionInfo(sessionInfo = ret, createSession = True, **kwargs)
        return ret

    def __init__(self):
        self._md5       = hashlib
        self._stree     = C_snode.C_stree()
        self.DB_build()

class ChRIS_SMCore(object):
    """The ChRIS_SM core

    """

    __metaclass__   = abc.ABCMeta

    def __init__(self, **kwargs):
        self.s_tree     = C_snode.C_stree()
        self._userDB    = ChRIS_SMUserDB()

    def login(self, **kwargs):
        return(self._userDB.user_login(**kwargs))

class ChRIS_SM(object):
    """The ChRIS Simulated Machine


    """

    #
    # Class member variables -- if declared here are shared
    # across all instances of this class
    #
    _dictErr = {
        'subjectSpecFail'   : {
            'action'        : 'examining command line arguments, ',
            'error'         : 'it seems that no subjects were specified.',
            'exitCode'      : 10},
        'no_apiCall'   : {
            'action'        : 'examining command line arguemnts, ',
            'error'         : 'it seems that the required --apiCall is missing.',
            'exitCode'      : 11},
        'no_stateFile'   : {
            'action'        : 'examining command line arguemnts, ',
            'error'         : 'it seems that the required --stateFile is missing.',
            'exitCode'      : 12},
        'no_stateFileExist': {
            'action'        : 'checking on the <stateFile>, ',
            'error'         : 'a system error was encountered. Does the <stateFile> exist?',
            'exitCode'      : 20},
        'no_stateFileAccess': {
            'action'        : 'attempting to access the <stateFile>, ',
            'error'         : 'a system error was encountered. Does the <stateFile> exist?',
            'exitCode'      : 21},
        'no_authModuleSpec' : {
            'action'        : 'attempting to parse the API call, ',
            'error'         : 'the auth module was not specified',
            'exitCode'      : 30},
    }

    __metaclass__   = abc.ABCMeta

    def log(self, *args):
        '''
        get/set the internal pipeline log message object.

        Caller can further manipulate the log object with object-specific
        calls.
        '''
        if len(args):
            self._log = args[0]
        else:
            return self._log

    def name(self, *args):
        '''
        get/set the descriptive name text of this object.
        '''
        if len(args):
            self.__name = args[0]
        else:
            return self.__name


    def __init__(self, **kwargs):
        """The CHRIS_SM constructor.

        """

        self.__name                     = "ChRIS_SM"

        self._feedTree                  = C_snode.C_stree()
        self._SMCore                    = ChRIS_SMCore()
        self._name                      = ""
        self._log                       = message.Message()
        self._log.tee(True)
        self._log.syslog(True)

        # Convenience members
        self.DB                         = self._SMCore._userDB

        self._str_apiCall               = ""
        self._l_apiCallHistory          = []

        # The returnStore variables control how json objects are
        # captured from API calls. Essentially the python exec
        # stores the return value in _str_returnStore and then
        # print()s it to stdout.
        self._b_returnStore             = False
        self._str_returnStore           = ""

    @abc.abstractmethod
    def build(self, **kwargs):
        """Build a ChRIS_SM instance.


        Args:
            **kwargs (user=): The user who is creating the feed

        Returns:
          True if successful, False otherwise.

        """

    @property
    def feedTree(self):
        """STree Getter"""
        return self._feedTree

    @feedTree.setter
    def feedTree(self, value):
        """STree Getter"""
        self._feedTree = value

    def login(self, **kwargs):
        loginStatus = self._SMCore.login(**kwargs)
        #self._str_loginTimeStamp = loginStatus['loginTimeStamp']
        return(loginStatus)

    def feed_nextID(self):
        """Find the next ID in the Feed database

        Returns:
            nextID (string): The next ID to use for a Feed.
        """

class ChRIS_SMFS(ChRIS_SM):
    """The ChRIS_SMFS subclass implements a ChRIS_SM using the filesystem as persistent state.


    """

    def __init__(self, **kwargs):
        """Constructor.

        This essentially calls up the chain to the base constructor

        Args:
            astr_FeedRepo (string): A location on the file system that houses
                all the feeds.

        """
        ChRIS_SM.__init__(self, **kwargs)

        self._b_clearStateFile  = False
        self._str_stateFile     = ""
        for key,val in kwargs.iteritems():
            if key == 'stateFile':  self._str_stateFile = val
            if key == 'APIcall':    self._str_apiCall   = val

        if self._str_stateFile  == "<void>": error.fatal(self, 'no_stateFile')
        if self._str_apiCall    == "<void>": error.fatal(self, 'no_apiCall')

        self.build()

    def build(self, **kwargs):
        """Build a ChRIS_SM instance.

        """
        f = self._feedTree
        l_Feed  = ['Feed-1', 'Feed-2', 'Feed-3', 'Feed-4']
        l_FID   = ['000001', '000002', '000003', '000004']
        f.mknode(l_Feed)
        for node, id in zip(l_Feed, l_FID):
            f.cd('/%s' % node)
            f.touch("ID", id)
            f.touch("Feed", feed.Feed_FS(
                                repo='Repo-%s' % node,
                                desc='Node Object Name: %s; Node FID: %s' % (node, id)))

    def API_readCallHistory(self):
        """Reads the (parsed) API calls stored in the stateful file.

        Since the ChRIS_SM effectively only executes *one* API
        call before terminating, it needs some mechanism for restoring
        state. This is done by replaying all previous API calls
        pertinent to this session.

        If the stateFile does not exist, this method will create an
        empty stateFile.

        Returns:
            state (boolean): True if all previous commands haven been read.
        """

        if not os.path.isfile(self._str_stateFile):
            open(self._str_stateFile, 'a').close()
            return False
        with open(self._str_stateFile) as f:
            self._l_apiCallHistory = f.read().splitlines()
        return True

    def API_parseCurrentCall(self, **kwargs):
        """Parses the apiCall and updates the stateFile.

        This method parses the <apiCall>, executes it, and updates
        the call to the stateFile, also adding the parsed call to
        the self._l_apiCallHistory list.

        Also parses the authentication.

        Returns:
            state (boolean): True if <apiCall> parsed

        """

        str_auth        = ""
        for key,value in kwargs.iteritems():
            if key == 'authmodule':         auth                    = value

        if not len(auth._name): error.fatal(self, 'no_authModuleSpec')

        # The main URL components
        str_auth        = auth._name
        str_ret         = ""
        str_object      = ""
        str_method      = ""
        str_parameters  = ""

        # Additional "auth" components
        str_user        = ""
        str_authHash    = ""

        d_component     = parse_qs(urlparse(self._str_apiCall).query)

        if 'clearSessionFile' in d_component:
            self._b_clearStateFile = int(d_component['clearSessionFile'][0])
        if 'returnstore' in d_component:
            str_ret                 = d_component['returnstore'][0]
            self._b_returnStore     = True
            self._str_returnStore   = str_ret
        else:
            self._b_returnStore     = False
            self._str_returnStore   = "APIreturn"
        if 'object'      in d_component: str_object      = d_component['object'][0]
        str_method      = d_component['method'][0]
        str_parameters  = d_component['parameters'][0]
        if len(str_ret):    str_ret     = "%s="   % str_ret
        if len(str_object): str_object  = "%s(lambda: %s."     % (str_auth, str_object)

        # Parse the "auth" components
        if 'auth'       in d_component:
            str_authSpec    = d_component['auth'][0]
            str_authUrl     = "?%s" % str_authSpec.replace(',', '&')
            d_auth          = parse_qs(urlparse(str_authUrl).query)
            str_user        = d_auth['user'][0]
            str_hash        = d_auth['hash'][0]

        str_eval    = "%s%s%s(%s)" % (
                                     str_ret,
                                     str_object,
                                     str_method,
                                     str_parameters
                                    )
        if len(str_object):
            if str_method == 'login':
                str_eval += ")"
            else:
                str_eval += ", user=%s, hash=%s)" % (str_user, str_hash)
        self._l_apiCallHistory.append(str_eval)
        #print(d_component)
        str_mode = 'a'
        #print("clear state file = %d" % self._b_clearStateFile)
        if self._b_clearStateFile: str_mode = 'w'
        with open(self._str_stateFile, str_mode) as f:
            f.write("# %s %s\n" % (datetime.datetime.now(), self._str_apiCall))
            f.write("%s\n" % str_eval)

    def API_replayCalls(self):
        """Play back calls stored in the internal list buffer.

        Since this effectively just "runs" the python commands in the
        statefile, this should typically execute at the highest level/scope
        of the program, i.e. at the __main__ level!

        The "current" API call is the last entry. All previous entries
        are replayed.

        The last entry is edited so that its return value is captured and
        printed to stdout.

        Preconditions:
            self._l_apiCallHistory is populated.

        Returns:
            state (boolean): The return value of each command as executed
        """

        # Play out the previous API calls to restore state up to current call
        for cmd in self._l_apiCallHistory[0:-1]:
            if cmd[0] != "#": exec(cmd)

        # Now process the current call.
        # First, we capture the API call itself from the client to return
        # in the 'APIcall' field of the return structure
        str_API     = self._str_apiCall
        d_API       = {'APIcall': str_API}

        # And similarly for the actual python call
        cmd         = self._l_apiCallHistory[-1]
        d_cmd       = {'pycode': cmd}

        print("{")
        if self._b_returnStore:
            cmd = "%s; strout = str(%s); print(\"'exec':\", end=\" \"); print(strout, end=\" \"); print(\",\", end=\" \")" % (cmd, self._str_returnStore)
        else:
            cmd = "%s = %s; strout = (%s); print(\"'exec':\", end=\" \"); print(strout, end=\" \"); print(\",\", end=\" \")" % (self._str_returnStore, cmd, self._str_returnStore)
        # print(cmd)
        exec(cmd)

        # Get the user's auth data
        d_component = parse_qs(urlparse(str_API).query)
        if 'auth' in d_component:
            str_userSpec    = d_component['auth'][0]
        if d_component['method'][0] == 'login':
            str_userSpec    = d_component['parameters'][0]
        d_params    = dict(token.split('=') for token in shlex.split(str_userSpec.replace(',', ' ')))
        str_user    = d_params['user']
        d_auth      = self.DB.user_getAuthInfo(user=str_user)
        s_auth      = "'auth': %s," % d_auth
        # print(s_auth.strip())
        print("'auth': %s," % d_auth)
        print("'API': %s,"  % d_API)
        print("'cmd': %s"   % d_cmd)
        print("}")

    def feed_existObjectName(self, astr_feedObjectName):
        """Check if a feed exists.

        Simply checks if a given feed with passed feedObjectName exists. The
        feedObjectName is the actual object record name in the snode tree.
        Searching on feed object name is much quicker than querying
        each feed for its ID.

        Args:
            astr_feedObjectName (string): The Feed Object Name.

        Returns:
            exists (boolean): True if exists, False if not.

        """
        f = self._feedTree
        f.cd('/')
        if f.cd(astr_feedObjectName):
            return True
        else:
            return False

    def feed_existFeedID(self, astr_feedID):
        """Check if a feed exists.

        Simply checks if a given feed with passed ID exists. This method needs
        to loop over all feeds and check their internal ID string.

        Args:
            astr_feedID (string): The Feed ID.

        Returns:
            exists (boolean): True if exists, False if not.

        """
        f = self._feedTree
        l_feed = f.lstr_lsnode('/')
        for feedNode in f.lstr_lsnode('/'):
            f.cd('/%s' % feedNode)
            str_ID = f.cat('ID')
            if str_ID == astr_feedID:
                return True
        return False

    def feed_getFromObjectName(self, astr_feedObjectName, **kwargs):
        """Get a feed from its internal object name

        This returns a feed by directly returning the object
        in the snode tree with the given feedObjectName.

        Args:
            astr_feedObjectName (string): The Feed Object Name.

        Returns:
            Feed (Feed): The Feed itself if it exists, False if not.
        """

        b_returnAsDict = False

        for key,val in kwargs.iteritems():
            if key == "returnAsDict":   b_returnAsDict = val

        f = self._feedTree
        f.cd('/')
        if f.cd(astr_feedObjectName):
            if b_returnAsDict:
                return dict(f.cat('Feed'))
            else:
                return f.cat('Feed')
        else:
            return False

    def feed_getFromID(self, astr_feedID):
        """Get a feed from its internal ID string.

        :param astr_feedID: The ID of the Feed to get
        :return: False if not found, otherwise the Feed object
        """
        f = self._feedTree
        l_feed = f.lstr_lsnode('/')
        for feedNode in f.lstr_lsnode('/'):
            f.cd('/%s' % feedNode)
            str_ID = f.cat('ID')
            if str_ID == astr_feedID:
                return f.cat('Feed')
        return False

    def __call__(self, f):
        """The wrapper around actual method calls -- allows for
        authentication checking.

        This method is the main "gatekeeper" between external API
        calls and actual methods in ChRIS system. It serves as a
        central entry point for each call so that user token
        authentication can be verified, as well as any additional
        parsing on the actual attempt to exec code.

        :param args:
        :param kwargs:
        :return:
        """
        print("In ChRIS_SM.__call__()")
        return f()

class ChRIS_authenticate(object):
    """The ChRIS_authenticate object is responsible for authenticated valid
        access to the API

        This method is the main "gatekeeper" between external API
        calls and actual methods in ChRIS system. It serves as a
        central entry point for each call so that user token
        authentication can be verified, as well as any additional
        parsing on the actual attempt to exec code.

        Since this method calls the passed "function" without regard for
        scope, the called object must actually exist at the scope at which
        this auth is being wrapped.

    """

    def __init__(self, achris_instance, aself_name):
        """Constructor.

        Builds a ChRIS_authenticate object. This object acts as a functor that calls
        into a ChRIS object after checking the authentication of the caller.

        Args:
            achris_instance (ChRIS):    the chris instance to authenticate against
            aself_name (string):        this object's string name
        """
        self._chris         = achris_instance
        self._name          = aself_name

    def __call__(self, f, **kwargs):
        """Call the object/method

        This functor actually wraps around the call, and is the main entry point to
        calling ANYTHING from ChRIS. It is here where the authentication of the
        caller/hash is verified before executing the actual object.method call

        Args:
            f (object.method):  The object.method to call.

        Returns:
            Whatever is returned by the call is returned back.
        """
        #print("In auth.__call__()")

        str_user    = ""
        str_hash    = ""
        for key,value in kwargs.iteritems():
            if key == 'user':       str_user    = value
            if key == 'hash':       str_hash    = value

        db = self._chris._SMCore._userDB
        db.user_checkAPIcanCall(**kwargs)
        return f()


def warn(*objs):
    print("WARNING: ", *objs, file=sys.stderr)

def synopsis(ab_shortOnly = False):
    scriptName = os.path.basename(sys.argv[0])
    shortSynopsis =  '''
    SYNOPSIS

            %s                                     \\
                            --stateFile <stateFile>         \\
                            --APIcall <apiCall>


    ''' % scriptName

    description =  '''
    DESCRIPTION

        `%s' simulates a ChRIS machine, and specifically the
        web service interface to the machine.

    ARGS

       --stateFile <stateFile> (required)
       The file that tracks calls pertinent to a specific session.
       API calls are logged to <stateFile> and replayed back when
       ChRIS_SM is instantiated. In this manner the machine state
       can be rebuilt. The current <apiCall> is appended to the
       <stateFile>.

       --apiCall <apiCall> (required)
       The actual API call to make.

    EXAMPLES


    ''' % (scriptName)
    if ab_shortOnly:
        return shortSynopsis
    else:
        return shortSynopsis + description


if __name__ == "__main__":
    """Simulated session interacting with the ChRIS_SM

    Once logged in, the client and service use a hash to authenticate.
    Essentially, on first login, the system returns a token to the client
    and an initial seed. The client hashes the token and seed when
    communicating with the service. For each communication, the service
    returns a new seed that must be used in the next comms.

    State is preserved in the SM by tracking all "api" calls  to a
    stateful file, and replaying them in order on subsequent runs.
    The current "api" call is appended to this stateful file.

    """

    if len(sys.argv) == 1:
        print(synopsis())
        sys.exit(1)

    parser      = argparse.ArgumentParser(description = synopsis(True))
    parser.add_argument(
        '-s', '--stateFile',
        help    =   "The <stateFile> keeps track of ChRIS state.",
        dest    =   'str_stateFileName',
        action  =   'store',
        default =   "<void>"
    )
    parser.add_argument(
        '-a', '--APIcall',
        help    =   "The actual API call to make.",
        dest    =   'str_apiCall',
        action  =   'store',
        default =   "<void>"
    )

    args        = parser.parse_args()

    chris       = ChRIS_SMFS(
                        stateFile   = args.str_stateFileName,
                        APIcall     = args.str_apiCall
    )

    auth        = ChRIS_authenticate(chris, 'auth')

    chris.API_readCallHistory()
    chris.API_parseCurrentCall(authmodule = auth)
    chris.API_replayCalls()



