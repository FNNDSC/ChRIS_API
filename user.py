#!/usr/bin/env python

# -*- coding: utf-8 -*-
"""

 _____ _    ______ _____ _____   _   _ _ _
/  __ \ |   | ___ \_   _/  ___| | | | | | |
| /  \/ |__ | |_/ / | | \ `--.  | | | | | |_ _ __ ___  _ __
| |   | '_ \|    /  | |  `--. \ | | | | | __| '__/ _ \| '_ \
| \__/\ | | | |\ \ _| |_/\__/ / | |_| | | |_| | | (_) | | | |
 \____/_| |_\_| \_|\___/\____/   \___/|_|\__|_|  \___/|_| |_|



font generated by:
http://patorjk.com/software/taag/#p=display&f=Doom&t=ChRIS%20Ultron

This module implements a tree (snode) container type structure for a 
user that holds feeds and top-level plugins.

"""

import  abc
import  json
import  sys
import  datetime

import  C_snode
import  message

import  feed
import  plugin


class UserTree(object):
    """
    Implements various operations on a collection (tree) of user objects.

    A user is a collection of regularly organized data that lends itself
    logically to expression as a (directory) tree.
    
    Semantically, user objects are either
    
        'Feeds'
        'Plugins'

    which differ only in their internal records. A 'Plugin' has a set of
    variable inputs on which it performs some aciton, generating essentially
    a dataTree as output. This dataTree is packaged either in a feed (with title,
    note, comments) or connected to a previous dataTree via the plugin.

    Additionally, a 'Feed' can contain a 'Plugin' tree which in turn can contain
    other 'Feed' trees.
    
    Also, a 'Plugin' creates a 'Feed' as output. This output 'Feed' can either
    reside at the root level of the user data space, or can be embedded as part of 
    a parent 'Feed' tree.


    A UserTree looks like:

        /<userName>
            +---------/Feeds/NAME_*
            +---------/Plugins/NAME_*
    
    """

    def log(self, *args):
        """
        get/set the internal pipeline log message object.

        Caller can further manipulate the log object with object-specific
        calls.
        """
        if len(args):
            self._log = args[0]
        else:
            return self._log

    def name(self, *args):
        """
        get/set the descriptive name text of this object.
        """
        if len(args):
            self.__name = args[0]
        else:
            return self.__name

    def __init__(self, **kwargs):
        """Construct a tree -- typically there is one tree per user

        """
        self._userTree              = C_snode.C_stree()
        self.debug                  = message.Message(logTo = './debug.log')
        self.debug._b_syslog        = True
        self._log                   = message.Message()
        self._log._b_syslog         = True
        self.__name                 = "UserTree"

        self.str_user               = '<void>'

        self.b_constructAllFeeds    = True

        for key,val in kwargs.iteritems():
            if key == 'user':                   self.str_user               = val
            if key == 'constructAllFeeds':      self.b_constructAllFeeds    = val

        self.FT                 = feed.FeedTree_chrisUser(constructAllFeeds = self.b_constructAllFeeds,
                                                          within = self)
        self.PT                 = plugin.Plugin_FS(within = self)
        if not self.b_constructAllFeeds:
            self.FT._feedTree   = C_snode.C_stree()
            self.PT._pluginTree = C_snode.C_stree()

        U                       = self._userTree
        U.cd('/')
        if self.str_user != '<void>':
            U.mkdir(self.str_user)

    def user_existObjectName(self, astr_userObjectName):
        """Check if a user exists.

        Simply checks if a given user with passed userObjectName exists. The
        userObjectName is the actual object record name in the snode tree.
        Searching on user object name is much quicker than querying
        each user for its ID.

        Args:
            astr_userObjectName (string): The Branch Object Name.

        Returns:
            exists (boolean): True if exists, False if not.

        """
        f = self._userTree
        f.cd('/')
        if f.cd(astr_userObjectName):
            return True
        else:
            return False

    def REST_process(self, **kwargs):
        """
        Get a feed based on various criteria
        :param kwargs: searchType = 'name' | 'id', target = <target>
        :return: Branch conforming to search criteria
        """
        b_returnAsDict      = True

        str_searchType      = ''
        str_searchTarget    = ''
        str_pathInBranch      = ''

        d_ret               = {
            'VERB':             'GET',
            'ROOT':             'Feed',
            'payloadFile':      '',
            'branch':           None,
            'debug':            'REST_process(): ',
            'path':             '',
            'pathInBranch':     '',
            'b_status':         False,
            'payload':          {},
            'URL_get':          [],
            'b_returnTree':     True
        }

        for key,val in kwargs.iteritems():
            if key == 'VERB':           d_ret['VERB']           = val
            if key == 'ROOT':           d_ret['ROOT']           = val
            if key == 'payloadFile':    d_ret['payloadFile']    = val
            if key == 'returnAsDict':   b_returnAsDict          = val
            if key == 'searchType':     str_searchType          = val
            if key == 'searchTarget':   str_searchTarget        = val
            if key == 'pathInBranch':   str_pathInBranch        = val
            if key == 'schema':         str_schema              = val

        kwargs['d_ret'] = d_ret

        # First get the user tree itself from the tree of users...
        U               = self._userTree
        U.cd('/%s' % self.str_user)
        str_branchSpec    = '%s__%s' % (str_searchType.upper(), str_searchTarget)

        if d_ret['ROOT'] == 'Feeds':
            T = self.FT
            T.BR._branchTree    = T._feedTree
        if d_ret['ROOT'] == 'Plugins':
            T = self.PT
            T.BR._branchTree    = T._pluginTree

        # Check if we want a list of all branches for this user
        if not len(str_searchType) or not len(str_searchTarget) or str_searchTarget == '*':
            d_ret           = T.BR.branch_branchList_fromTreeGet(**kwargs)
            d_ret['debug'] += "Search for '%s' on type '%s'" % (str_searchTarget, str_searchType)
        else:
            # Or if we just want one specific feed
            d_ret       = T.BR.branch_singleBranch_fromTreeGet(**kwargs)

            # and now, check for any paths in the tree of this Branch
            if len(str_pathInBranch) and str_pathInBranch != '/':
                self.debug('Path in Branch: %s\n' % str_pathInBranch)
                d_ret           = T.BR.branch_singleBranch_process(**kwargs)

            # b_returnTree is always True, unless a "file" is being returned
            if b_returnAsDict and d_ret['b_returnTree']:
                d_ret['branch'] = dict(d_ret['branch'].snode_root)
            d_ret['payload']    = d_ret['branch']
            d_ret['URL_get']    = T.BR.branch_GETURI(branchSpec = str_branchSpec, path = str_pathInBranch, ROOT = d_ret['ROOT'])

        # Pop the "temp" key 'feed' from the return stack
        if 'branch' in d_ret: d_ret.pop('branch')

        # Set the 'path'
        d_ret['path']   = str_searchTarget + str_pathInBranch
        return d_ret

class UserTree_chrisUser(UserTree):
    """
    A Branch Tree for a hypothetical user on the ChRIS system. Each user will
    have identical trees under this scenario.
    """

    def __init__(self, **kwargs):
        """
        Build the tree.

        :return:
        """
        UserTree.__init__(self, **kwargs)

        U   = self._userTree
        F   = self.FT._feedTree
        P   = self.PT._pluginTree

        U.cd('/%s' % self.str_user)
        U.graft(F, '/feeds')
        U.graft(P, '/plugins')
        U.cd('feeds')
        U.mknode(['plugins'])
        U.graft(P, '/plugins')

        F.tree_metaData_print(False)
        U.tree_metaData_print(False)

if __name__ == "__main__":
    UT  = UserTree_chrisUser(user = 'chris')
    U   = UT._userTree

    print(U)