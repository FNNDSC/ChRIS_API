#!/usr/bin/env python


"""

 _____ _    ______ _____ _____   _   _ _ _
/  __ \ |   | ___ \_   _/  ___| | | | | | |
| /  \/ |__ | |_/ / | | \ `--.  | | | | | |_ _ __ ___  _ __
| |   | '_ \|    /  | |  `--. \ | | | | | __| '__/ _ \| '_ \
| \__/\ | | | |\ \ _| |_/\__/ / | |_| | | |_| | | (_) | | | |
 \____/_| |_\_| \_|\___/\____/   \___/|_|\__|_|  \___/|_| |_|



font generated by:
http://patorjk.com/software/taag/#p=display&f=Doom&t=ChRIS%20Ultron

This module implements a simple comment-type class

"""

import  abc
import  json

import  os
import  sys

import  argparse
import  dataTree

import  C_snode

sys.path.append('components/faker')

import faker

class data(object):
    """
    This class implements a ChRIS style data object container, accessible
    in a tree like structure, i.e.:

        /data/contents/fileView
        /data/contents/dataView
        /data/contents/plugin
        /data/contents/plugin/list
        /data/contents/plugin/<timeStamp>/parameters
        /data/contents/plugin/<timeStamp>/name
        /data/contents/plugin/<timeStamp>/results

    The data container encapsulates three components:

        contents
            \
            +--- fileView
            \
            +--- visualView
            \
            +--- plugins
    """

    __metaclass__   = abc.ABCMeta

    def __init__(self, **kwargs):

        self.contents   = ""
        self.tree       = C_snode.C_stree
        self.tree.cd('/')
        self.tree.mknode(['contents'])
        self.fake       = faker.Faker()


    def dataComponent_build(self, **kwargs):
        """
        This method builds a "single" dataComponent
        and adds to the internal tree at a specified
        path.

        A data component consists of:

            * dataView
                - "files" for visualizing
            * fileView
                - "files" in a traditional tree view
            * plugin
                - list of plugins to choose from for this data/fileView
                - plugin that has been applied to the data/fileView
        :param kwargs:
        :return:
        """

        str_path            = '/contents'
        str_data            = 'PACSPull'
        convertFrom         = None
        SeriesFilesCount    = 3
        dataTree            = None
        for key,val in kwargs.iteritems():
            if key == 'path':               str_path            = val
            if key == 'data':               str_data            = val
            if key == 'tree_convertFrom':   ft_convertFrom      = val
            if key == 'type_convertTo':     str_convertTo       = val
            if key == 'SeriesFilesCount':   SeriesFilesCount    = val

        s = self.stree

        if s.cd(str_path)['status']:
            s.mknode(['dataView', 'fileView', 'plugin'])
            if str_data.lower() == 'pacspull':
                dataTree = self.dataTree_PACSPull_build(
                                SeriesFilesCount   = SeriesFilesCount
                            )
                s.cd('/dataView')
                s.graft(dataTree, '/files')
                s.cd('/fileView')
                s.graft(dataTree, '/files')
            else:
                if convertFrom and len(convertTo)

    def dataComponent_pluginBuild(self, **kwargs):
        """
        Build the plugin tree on a specific data component.
        :param kwargs: 'path'=<path>
        :return:
        """
        str_path            = '/contents'
        str_selected        = 'mri_convert'
        for key,val in kwargs.iteritems():
            if key == 'path':               str_path            = val
            if key == 'selected':           str_selected        = val

        s = self.stree

        if s.cd(str_path)['status']:
            if not s.cd('list_pluginRunFromHere')['status']:
                s.mknode(['list_pluginRunFromHere'])
            rand_date       = self.fake.date_time_this_decade()
            str_timestamp   = rand_date.isoformat()
            s.mkcd(str_timestamp)
            s.mknode(['parameters', 'results'])
            s.touch('name', str_selected)

    def dataTree_mriConvert_build(self, **kwargs):
        """
        Convert an input tree (typically from PACSPull) to
        a different format.

        :param kwargs: PACSPullTree = <Tree>, extention = <ext>
        :return: converted tree
        """
        ft_converted    = None
        ft_PACSPull     = None
        str_extension   = 'nii'
        for key, val in kwargs.iteritems():
            if key == 'PACSPullTree':   ft_PACSPull     = val
            if key == 'extension':      str_extension   = val

        ft_converted    = dataTree.dataTree_convert(
            PACSPullTree    = ft_PACSPull,
            convertTo       = str_extension
        )

        return ft_converted

    def dataTree_PACSPull_build(self, **kwargs):
        """
        Build a PACSPull tree.
        :param kwargs:  SeriesFilesCount = <count>
        :return: PACSPull tree
        """

        SeriesFilesCount = 1
        for key,val in kwargs.iteritems():
            if key == 'SeriesFilesCount':       SeriesFilesCount = int(val)

        ft_PACSPull         = dataTree.dataTree_PACSPull(SeriesFilesCount = SeriesFilesCount)

        ft_dataView00   = dataTree.dataTree_convert(
            PACSPullTree    = ft_PACSPull.FS,
            convertTo       = 'nii'
        )
        ft_dataView01   = dataTree.dataTree_convert(
            PACSPullTree    = ft_PACSPull.FS,
            convertTo       = 'mgz'
        )

        s           = self.tree

        # print(ft_dataView.FS)
        # print(ft_dataView2.FS)
        # sys.exit(0)

        s.mknode(['dataView', 'fileView', 'plugin'])
        for node in ft_dataView.FS.lstr_lsnode('/'):
            s.cd('/dataView')
            s.graft(ft_dataView.FS, '/' + node)
            s.cd('/fileView')
            s.graft(ft_dataView.FS, '/' + node)

        s.cd('/plugin')
        s.mknode(['0', '1'])
        for node in ft_dataView00.FS.lstr_lsnode('/'):
            s.cd('/plugin/0')
            s.graft(ft_dataView00.FS, '/' + node)
        for node in ft_dataView01.FS.lstr_lsnode('/'):
            s.cd('/plugin/1')
            s.graft(ft_dataView01.FS, '/' + node)
        s.tree_metaData_print(False)

        print(s.l_allPaths)
        print(s.pathFromHere_explore('/'))
        print(s)
        self.contents = {'tree':    self.tree}
        return ft_PACSPull.FS

    def __iter__(self):
        yield('data', dict(self.tree.snode_root))

def synopsis(ab_shortOnly = False):
    scriptName = os.path.basename(sys.argv[0])
    shortSynopsis =  '''
    SYNOPSIS

            %s                                     \\
                            --fileCount <numberOfFiles>


    ''' % scriptName

    description =  '''
    DESCRIPTION

        `%s' is a simple "data" object container for ChRIS. It encapsulates
        an interactive visual viewer and a file finder/explorer component,
        as well as plugin component.

    ARGS

       --fileCount <fileCount>
       The number of simulated files to generate.


    ''' % (scriptName)
    if ab_shortOnly:
        return shortSynopsis
    else:
        return shortSynopsis + description

if __name__ == "__main__":

    parser      = argparse.ArgumentParser(description = synopsis(True))
    parser.add_argument(
        '-f', '--SeriesFilesCount',
        help    =   "The number of simulated DICOM filenames to generate.",
        dest    =   'SeriesFilesCount',
        action  =   'store',
        default =   10
    )

    args        = parser.parse_args()

    container   = data()
    container.contents_build(SeriesFilesCount = args.SeriesFilesCount)

    # print(container.tree)
    # print(json.dumps(dict(container)))

