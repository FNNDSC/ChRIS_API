#!/usr/bin/env python


"""

 _____ _    ______ _____ _____   _   _ _ _
/  __ \ |   | ___ \_   _/  ___| | | | | | |
| /  \/ |__ | |_/ / | | \ `--.  | | | | | |_ _ __ ___  _ __
| |   | '_ \|    /  | |  `--. \ | | | | | __| '__/ _ \| '_ \
| \__/\ | | | |\ \ _| |_/\__/ / | |_| | | |_| | | (_) | | | |
 \____/_| |_\_| \_|\___/\____/   \___/|_|\__|_|  \___/|_| |_|



font generated by:
http://patorjk.com/software/taag/#p=display&f=Doom&t=ChRIS%20Ultron

This module implements a simple comment-type class

"""

import  abc
import  json

import  os
import  sys

import  argparse
import  dataTree

import  C_snode

sys.path.append('components/faker')

import faker

class data(object):
    """
    This class implements a ChRIS style data object container, accessible
    in a tree like structure, i.e.:

        /data/contents/fileView
        /data/contents/dataView
        /data/contents/plugin
        /data/contents/plugin/list
        /data/contents/plugin/<timeStamp>/parameters
        /data/contents/plugin/<timeStamp>/name
        /data/contents/plugin/<timeStamp>/results

    The data container encapsulates three components:

        contents
            \
            +--- fileView
            \
            +--- visualView
            \
            +--- plugins
    """

    _dict_plugin = {
        'mri_convert' : {
            'name':         'mri_convert',
            'args':         {
                                'convertTo':    'nii, mgh, img'
                            },
            'executable':   'mri_convert',
            'resultTree':   'dataTree_convert'
        },
        'recon-all' : {
            'name':         'recon-all',
            'args':         {
                'arg1':     'val1',
                'arg2':     'val2'
            },
            'executable':   'recon-all',
            'resultTree':   'dataTree_recon-all'
        },
        'zip' : {
            'name':         'zip',
            'args':         {
                'arg1':     'val1',
                'arg2':     'val2'
            },
            'executable':   'zip',
            'resultTree':   'dataTree_convert'
        },
        'tractography' : {
            'name':         'tractography',
            'args':         {
                'arg1':     'val1',
                'arg2':     'val2'
            },
            'executable':   'dtk',
            'resultTree':   'dataTree_tractography'
        }
    }

    __metaclass__   = abc.ABCMeta

    def __init__(self, **kwargs):

        self.contents   = ""
        self.tree       = C_snode.C_stree
        self.tree.cd('/')
        self.tree.mknode(['contents'])
        self.fake       = faker.Faker()


    def dataComponent_build(self, **kwargs):
        """
        This method builds a "single" dataComponent
        and adds to the internal tree at a specified
        path.

        A data component consists of:

            * dataView
                - "files" for visualizing
            * fileView
                - "files" in a traditional tree view
            * plugin
                - list of plugins to choose from for this data/fileView
                - plugin that has been applied to the data/fileView
        :param kwargs:
        :return:
        """

        str_path            = '/contents'
        str_plugin          = 'PACSPull'
        ft_convertFrom      = None
        str_convertTo       = ''
        SeriesFilesCount    = 3
        dataTree            = None
        for key,val in kwargs.iteritems():
            if key == 'path':               str_path            = val
            if key == 'plugin':             str_plugin          = val
            if key == 'tree_convertFrom':   ft_convertFrom      = val
            if key == 'type_convertTo':     str_convertTo       = val
            if key == 'SeriesFilesCount':   SeriesFilesCount    = val

        s = self.stree

        if s.cd(str_path)['status']:
            s.mknode(['dataView', 'fileView', 'plugin'])
            s.cd('plugin')
            if str_plugin.lower() == 'pacspull':
                dataTree = self.dataTree_PACSPull_build(
                                SeriesFilesCount   = SeriesFilesCount
                            )
            if str_plugin.lower == 'mri_convert':
                if ft_convertFrom and len(str_convertTo):
                    dataTree = self.dataTree_mriConvert_build(
                        PACSPullTree    = ft_convertFrom,
                        convertTo       = str_convertTo
                    )
            if str_plugin.lower() == 'recon-all':
                dataTree    = self.dataTree_recon-all()
            if str_plugin.lower() == 'tractography':
                dataTree    = self.dataTree_tractography()
            s.cd('dataView')
            s.graft(dataTree, '/files')
            s.cd('fileView')
            s.graft(dataTree, '/files')

    def dataComponent_pluginBuild(self, **kwargs):
        """
        Build the plugin tree on a specific data component.
        :param kwargs: 'path'=<path>
        :return:
        """
        str_path            = '/contents/plugin'
        str_selected        = 'mri_convert'
        for key,val in kwargs.iteritems():
            if key == 'path':               str_path            = val
            if key == 'selected':           str_selected        = val

        s = self.stree

        if s.cd(str_path)['status']:
            self.pluginList_withinFeed()

    def pluginList_withinFeed(self, **kwargs):
        """
        Creates the "available" directory in the plugin directory within
        the larger feed hierarchy.

        This contains a list-ordered sub-tree, each with a plugin descriptor
        dictionary.


        :return:
        """

        str_path    = '/contents/plugin'
        for key,val in kwargs.iteritems():
            if key == 'path':           str_path        = val

        s = self.tree

        if s.cd(str_path)['status']:
            s.mkcd('available')
            s.mknode(data._dict_plugin.keys())
            for node in s.lstr_lsnode():
                s.cd(node)
                s.touch('detail', data._dict_plugin[node])
                s.cd('../')

    def dataComponent_pluginRun(self, **kwargs):
        """
        'Run' a few fake plugins.
        :param kwargs: 'path'=<path>
        :return:
        """
        str_outputPath      = '/contents/plugin'
        str_inputPath       = '/contents/dataView/files'

        str_plugin          = 'mri_convert'
        for key,val in kwargs.iteritems():
            if key == 'plugin':             str_plugin          = val
            if key == 'inputPath':          str_inputPath       = val
            if key == 'outputPath':         str_outputPath      = val

        s = self.stree

        if s.cd(str_outputPath)['status']:
            rand_date       = self.fake.date_time_this_decade()
            str_timestamp   = rand_date.isoformat()
            s.mkcd(str_timestamp)
            s.touch('detail', data._dict_plugin[str_plugin])
            s.mknode(['parameters', 'results'])
            s.touch('parameters/input', {
                'input':    '<some dictionary of all input parameters>'
            })
            s.cd('results')
            if str_plugin.lower() != 'pacspull' and str_plugin.lower() != 'mri_convert':
                self.dataComponent_build(
                    path    = s.cwd(),
                    plugin  = str_plugin
                )
            if str_plugin.lower() == 'mri_convert':
                inputTree   = C_snode.stree()
                inputTree.cd('/')
                inputTree.graft(s, str_inputPath)

                self.dataComponent_build(
                    path                = s.cwd(),
                    plugin              = str_plugin,
                    tree_convertFrom    = inputTree,
                    type_convertTo      = "nii"
                )


    def dataTree_mriConvert_build(self, **kwargs):
        """
        Convert an input tree (typically from PACSPull) to
        a different format.

        :param kwargs: PACSPullTree = <Tree>, extention = <ext>
        :return: converted tree
        """
        ft_converted    = None
        ft_PACSPull     = None
        str_extension   = 'nii'
        for key, val in kwargs.iteritems():
            if key == 'PACSPullTree':   ft_PACSPull     = val
            if key == 'extension':      str_extension   = val

        ft_converted    = dataTree.dataTree_convert(
            PACSPullTree    = ft_PACSPull,
            convertTo       = str_extension
        )

        return ft_converted

    def dataTree_PACSPull_build(self, **kwargs):
        """
        Build a PACSPull tree.
        :param kwargs:  SeriesFilesCount = <count>
        :return: PACSPull tree
        """

        SeriesFilesCount = 1
        for key,val in kwargs.iteritems():
            if key == 'SeriesFilesCount':       SeriesFilesCount = int(val)

        ft_PACSPull         = dataTree.dataTree_PACSPull(SeriesFilesCount = SeriesFilesCount)

        ft_dataView00   = dataTree.dataTree_convert(
            PACSPullTree    = ft_PACSPull.FS,
            convertTo       = 'nii'
        )
        ft_dataView01   = dataTree.dataTree_convert(
            PACSPullTree    = ft_PACSPull.FS,
            convertTo       = 'mgz'
        )

        s           = self.tree

        # print(ft_dataView.FS)
        # print(ft_dataView2.FS)
        # sys.exit(0)

        s.mknode(['dataView', 'fileView', 'plugin'])
        for node in ft_dataView.FS.lstr_lsnode('/'):
            s.cd('/dataView')
            s.graft(ft_dataView.FS, '/' + node)
            s.cd('/fileView')
            s.graft(ft_dataView.FS, '/' + node)

        s.cd('/plugin')
        s.mknode(['0', '1'])
        for node in ft_dataView00.FS.lstr_lsnode('/'):
            s.cd('/plugin/0')
            s.graft(ft_dataView00.FS, '/' + node)
        for node in ft_dataView01.FS.lstr_lsnode('/'):
            s.cd('/plugin/1')
            s.graft(ft_dataView01.FS, '/' + node)
        s.tree_metaData_print(False)

        print(s.l_allPaths)
        print(s.pathFromHere_explore('/'))
        print(s)
        self.contents = {'tree':    self.tree}
        return ft_PACSPull.FS

    def __iter__(self):
        yield('data', dict(self.tree.snode_root))

def synopsis(ab_shortOnly = False):
    scriptName = os.path.basename(sys.argv[0])
    shortSynopsis =  '''
    SYNOPSIS

            %s                                     \\
                            --fileCount <numberOfFiles>


    ''' % scriptName

    description =  '''
    DESCRIPTION

        `%s' is a simple "data" object container for ChRIS. It encapsulates
        an interactive visual viewer and a file finder/explorer component,
        as well as plugin component.

    ARGS

       --fileCount <fileCount>
       The number of simulated files to generate.


    ''' % (scriptName)
    if ab_shortOnly:
        return shortSynopsis
    else:
        return shortSynopsis + description

if __name__ == "__main__":

    parser      = argparse.ArgumentParser(description = synopsis(True))
    parser.add_argument(
        '-f', '--SeriesFilesCount',
        help    =   "The number of simulated DICOM filenames to generate.",
        dest    =   'SeriesFilesCount',
        action  =   'store',
        default =   10
    )

    args        = parser.parse_args()

    container   = data()
    container.contents_build(SeriesFilesCount = args.SeriesFilesCount)

    # print(container.tree)
    # print(json.dumps(dict(container)))

