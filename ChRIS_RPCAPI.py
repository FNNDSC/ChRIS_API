#!/usr/bin/env python

# -*- coding: utf-8 -*-
"""

 _____ _    ______ _____ _____   _   _ _ _
/  __ \ |   | ___ \_   _/  ___| | | | | | |
| /  \/ |__ | |_/ / | | \ `--.  | | | | | |_ _ __ ___  _ __
| |   | '_ \|    /  | |  `--. \ | | | | | __| '__/ _ \| '_ \
| \__/\ | | | |\ \ _| |_/\__/ / | |_| | | |_| | | (_) | | | |
 \____/_| |_\_| \_|\___/\____/   \___/|_|\__|_|  \___/|_| |_|



font generated by:
http://patorjk.com/software/taag/#p=display&f=Doom&t=ChRIS%20Ultron
"""

from __future__ import print_function

str_desc = """



 _____ _    ______ _____ _____ ____________  _____   ___  ______ _____
/  __ \ |   | ___ \_   _/  ___|| ___ \ ___ \/  __ \ / _ \ | ___ \_   _|
| /  \/ |__ | |_/ / | | \ `--. | |_/ / |_/ /| /  \// /_\ \| |_/ / | |
| |   | '_ \|    /  | |  `--. \|    /|  __/ | |    |  _  ||  __/  | |
| \__/\ | | | |\ \ _| |_/\__/ /| |\ \| |    | \__/\| | | || |    _| |_
 \____/_| |_\_| \_|\___/\____/ \_| \_\_|     \____/\_| |_/\_|    \___/
                           ______
                          |______|

'ChRIS_RPCAPI' -- ChRIS RPC API handler -- processes the RPC API requests from
an external client.

This class/module is responsible for mapping the GET formatted REST requests
to actual ChRIS calls.

"""

from    urlparse        import urlparse, parse_qs

import  message
import  shlex
import  os
import  datetime

class ChRIS_RPCAPI(object):
    """This class processes GET verbs. Effectively it maps from the REST API
        to actual object.method calls."""

    #
    # Class member variables -- if declared here are shared
    # across all instances of this class
    #
    _dictErr = {
        'no_apiCall'   : {
            'action'        : 'examining command line arguemnts, ',
            'error'         : 'it seems that the required --apiCall is missing.',
            'exitCode'      : 11},
        'no_stateFile'   : {
            'action'        : 'examining command line arguemnts, ',
            'error'         : 'it seems that the required --stateFile is missing.',
            'exitCode'      : 12},
        'no_stateFileExist': {
            'action'        : 'checking on the <stateFile>, ',
            'error'         : 'a system error was encountered. Does the <stateFile> exist?',
            'exitCode'      : 20},
        'no_stateFileAccess': {
            'action'        : 'attempting to access the <stateFile>, ',
            'error'         : 'a system error was encountered. Does the <stateFile> exist?',
            'exitCode'      : 21}
    }


    def __init__(self, *args, **kwargs):

        self._b_clearStateFile          = False
        self._str_stateFile             = ""
        self._str_apiCall               = ""
        self._l_apiCallHistory          = []
        self.auth                       = None
        self.debug                      = message.Message(logTo = './debug.log')
        self.debug._b_syslog            = True

        # The returnStore variables control how json objects are
        # captured from API calls. Essentially the python exec
        # stores the return value in _str_returnStore and then
        # print()s it to stdout.
        self._b_returnStore             = False
        self._str_returnStore           = ""

        for key,val in kwargs.iteritems():
            if key == 'stateFile':  self._str_stateFile = val
            if key == 'auth':       self.auth           = val

        if self._str_stateFile  == "<void>": error.fatal(self, 'no_stateFile')

    def __call__(self, *args, **kwargs):
        '''
        :param args:
        :param kwargs:
        :return:
        '''
        # print("In __call__")
        for key,val in kwargs.iteritems():
            if key == 'APIcall':    self._str_apiCall   = val
        if self._str_apiCall    == "<void>": error.fatal(self, 'no_apiCall')
        # print(self._str_apiCall)
        self.readCallHistory()
        self.parseCurrentCall(authmodule = self.auth)
        self.replayCalls()

    def readCallHistory(self):
        """Reads the (parsed) API calls stored in the stateful file.

        Since the ChRIS_SM effectively only executes *one* API
        call before terminating, it needs some mechanism for restoring
        state. This is done by replaying all previous API calls
        pertinent to this session

        If the stateFile does not exist, this method will create an
        empty stateFile.

        Returns:
            state (boolean): True if all previous commands haven been read.
        """

        if not os.path.isfile(self._str_stateFile):
            open(self._str_stateFile, 'a').close()
            return False
        with open(self._str_stateFile) as f:
            self._l_apiCallHistory = f.read().splitlines()
        return True

    def parseCurrentCall(self, **kwargs):
        """Parses the apiCall and updates the stateFile.

        This method parses the <apiCall>, executes it, and updates
        the call to the stateFile, also adding the parsed call to
        the self._l_apiCallHistory list.

        Also parses the authentication.

        Returns:
            state (boolean): True if <apiCall> parsed

        """

        str_auth        = ""
        for key,value in kwargs.iteritems():
            if key == 'authmodule':         auth                    = value

        if not len(auth._name): error.fatal(self, 'no_authModuleSpec')

        # The main URL components
        str_auth        = auth._name
        str_ret         = ""
        str_object      = ""
        str_method      = ""
        str_parameters  = ""

        # Additional "auth" components
        str_user        = ""
        str_hash        = ""

        d_component     = parse_qs(urlparse(self._str_apiCall).query)

        if 'clearSessionFile' in d_component:
            self._b_clearStateFile = int(d_component['clearSessionFile'][0])
        if 'returnstore' in d_component:
            str_ret                 = d_component['returnstore'][0]
            self._b_returnStore     = True
            self._str_returnStore   = str_ret
        else:
            self._b_returnStore     = False
            self._str_returnStore   = "APIreturn"
        if 'object'      in d_component: str_object      = d_component['object'][0]
        str_method                  = d_component['method'][0]
        if 'parameters'  in d_component: str_parameters  = d_component['parameters'][0]
        if len(str_ret):    str_ret     = "%s="   % str_ret
        if len(str_object): str_object  = "%s(lambda: %s."     % (str_auth, str_object)

        # Parse the "auth" components
        if 'auth'       in d_component:
            str_authSpec    = d_component['auth'][0]
            str_authUrl     = "?%s" % str_authSpec.replace(',', '&')
            d_auth          = parse_qs(urlparse(str_authUrl).query)
            str_user        = d_auth['user'][0]
            str_hash        = d_auth['hash'][0]

        if len(str_parameters):
            str_eval    = "%s%s%s(%s)" % (
                str_ret,
                str_object,
                str_method,
                str_parameters
            )
        else:
            str_eval    = "%s%s%s()" % (
                str_ret,
                str_object,
                str_method
            )

        if len(str_object):
            if str_method == 'login':
                str_eval += ")"
            else:
                str_eval += ", user=%s, hash=%s)" % (str_user, str_hash)
        self._l_apiCallHistory.append(str_eval)
        #print(d_component)
        str_mode = 'a'
        #print("clear state file = %d" % self._b_clearStateFile)
        if self._b_clearStateFile: str_mode = 'w'
        with open(self._str_stateFile, str_mode) as f:
            f.write("# %s %s\n" % (datetime.datetime.now(), self._str_apiCall))
            f.write("%s\n" % str_eval)

    def replayCalls(self):
        """Play back calls stored in the internal list buffer.

        Since this effectively just "runs" the python commands in the
        statefile, this should typically execute at the highest level/scope
        of the program, i.e. at the __main__ level!

        The "current" API call is the last entry. All previous entries
        are replayed.

        The last entry is edited so that its return value is captured and
        printed to stdout.

        Preconditions:
            self._l_apiCallHistory is populated.

        Returns:
            state (boolean): The return value of each command as executed
        """

        auth        = self.auth
        chris       = self.auth.chris

        # Play out the previous API calls to restore state up to current call
        for cmd in self._l_apiCallHistory[0:-1]:
            if cmd[0] != "#":
                self.debug("replay cmd: %s\n" % cmd)
                exec(cmd) in locals()

        # Now process the current call.
        # First, we capture the API call itself from the client to return
        # in the 'APIcall' field of the return structure
        str_API     = self._str_apiCall
        d_API       = {'APIcall': str_API}

        # And similarly for the actual python call
        cmd         = self._l_apiCallHistory[-1]
        d_cmd       = {'pycode': cmd}

        print("{")
        if self._b_returnStore:
            cmd = "%s; strout = str(%s); print(\"'exec':\", end=\" \"); print(strout, end=\"\"); print(\",\", end=\" \")" % (cmd, self._str_returnStore)
        else:
            cmd = "%s = %s; strout = (%s); print(\"'exec':\", end=\" \"); print(strout, end=\"\"); print(\",\", end=\" \")" % (self._str_returnStore, cmd, self._str_returnStore)

        self.debug('this cmd: %s\n' % cmd)
        exec(cmd) in locals()

        # Get the user's auth data
        d_component = parse_qs(urlparse(str_API).query)
        if 'auth' in d_component:
            str_userSpec    = d_component['auth'][0]
        if d_component['method'][0] == 'login':
            str_userSpec    = d_component['parameters'][0]
        d_params    = dict(token.split('=') for token in shlex.split(str_userSpec.replace(',', ' ')))
        str_user    = d_params['user']
        d_auth      = chris.DB.user_getAuthInfo(user=str_user)
        s_auth      = "'auth': %s," % d_auth
        # print(s_auth.strip())
        print("\n'auth': %s,"   % d_auth)
        print("'API': %s,"      % d_API)
        print("'cmd': %s"       % d_cmd)
        print("}")
