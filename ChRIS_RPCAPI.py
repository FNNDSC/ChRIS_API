#!/usr/bin/env python

# -*- coding: utf-8 -*-
"""

 _____ _    ______ _____ _____   _   _ _ _
/  __ \ |   | ___ \_   _/  ___| | | | | | |
| /  \/ |__ | |_/ / | | \ `--.  | | | | | |_ _ __ ___  _ __
| |   | '_ \|    /  | |  `--. \ | | | | | __| '__/ _ \| '_ \
| \__/\ | | | |\ \ _| |_/\__/ / | |_| | | |_| | | (_) | | | |
 \____/_| |_\_| \_|\___/\____/   \___/|_|\__|_|  \___/|_| |_|



font generated by:
http://patorjk.com/software/taag/#p=display&f=Doom&t=ChRIS%20Ultron
"""

from __future__ import print_function

str_desc = """



 _____ _    ______ _____ _____ ____________  _____   ___  ______ _____
/  __ \ |   | ___ \_   _/  ___|| ___ \ ___ \/  __ \ / _ \ | ___ \_   _|
| /  \/ |__ | |_/ / | | \ `--. | |_/ / |_/ /| /  \// /_\ \| |_/ / | |
| |   | '_ \|    /  | |  `--. \|    /|  __/ | |    |  _  ||  __/  | |
| \__/\ | | | |\ \ _| |_/\__/ /| |\ \| |    | \__/\| | | || |    _| |_
 \____/_| |_\_| \_|\___/\____/ \_| \_\_|     \____/\_| |_/\_|    \___/
                           ______
                          |______|

'ChRIS_RPCAPI' -- ChRIS RPC API handler -- processes the RPC API requests from
an external client.

This class/module is responsible for mapping the GET formatted REST requests
to actual ChRIS calls.

"""

from    urlparse        import urlparse, parse_qs

import  error
import  message
import  shlex
import  os
import  datetime

import  ChRIS_SM
import  serverInfo
import  json

class ChRIS_RPCAPI(object):
    """This class processes GET verbs. Effectively it maps from the REST API
        to actual object.method calls."""

    #
    # Class member variables -- if declared here are shared
    # across all instances of this class
    #
    _dictErr = {
        'no_apiCall'   : {
            'action'        : 'examining command line arguemnts, ',
            'error'         : 'it seems that the required --apiCall is missing.',
            'exitCode'      : 11},
        'no_stateFile'   : {
            'action'        : 'examining command line arguemnts, ',
            'error'         : 'it seems that the required stateFile is missing from the constructor.',
            'exitCode'      : 12},
        'no_stateFileExist': {
            'action'        : 'checking on the <stateFile>, ',
            'error'         : 'a system error was encountered. Does the <stateFile> exist?',
            'exitCode'      : 20},
        'no_stateFileAccess': {
            'action'        : 'attempting to access the <stateFile>, ',
            'error'         : 'a system error was encountered. Does the <stateFile> exist?',
            'exitCode'      : 21},
        'no_authModuleSpec' : {
            'action'        : 'executing API call, ',
            'error'         : "there doesn't seem to be an auth module!",
            'exitCode'      : 22},
        'no_chrisModuleSpec' : {
            'action'        : 'building API object, ',
            'error'         : "the reference to the containing <chris> object is missing!",
            'exitCode'      : 23},
        'malformedURL' : {
            'action'        : 'parsing REST call, ',
            'error'         : "the URL itself didn't yield a path -- it might be malformed. Perhaps an extra '?'",
            'exitCode'      : 24}
    }

    def log(self, *args):
        '''
        get/set the internal pipeline log message object.

        Caller can further manipulate the log object with object-specific
        calls.
        '''
        if len(args):
            self._log = args[0]
        else:
            return self._log

    def name(self, *args):
        '''
        get/set the descriptive name text of this object.
        '''
        if len(args):
            self.__name = args[0]
        else:
            return self.__name


    def __init__(self, *args, **kwargs):

        # auth is the per-call authentication module
        self.auth                       = None
        # chris is the chris-object that contains this API
        self.chris                      = None

        self._b_clearStateFile          = False
        self._str_stateFile             = ""
        self._str_apiCall               = ""
        self._l_apiCallHistory          = []
        self.auth                       = None
        self.debug                      = message.Message(logTo = './debug.log')
        self.debug._b_syslog            = True
        self._log                       = message.Message()
        self._log._b_syslog             = True
        self.__name                     = "ChRIS_RESTAPI"

        self.user                       = ""
        self.hash                       = ""
        self.passwd                     = ""
        self.authority                  = "localhost:5555"

        # JSON return objects
        self.d_return                   = {}
        self.d_call                     = {}
        self.d_cmd                      = {}
        self.d_auth                     = {}
        self.d_API                      = {}

        # The returnStore variables control how json objects are
        # captured from API calls. Essentially the python exec
        # stores the return value in _str_returnStore and then
        # print()s it to stdout.
        self._b_returnStore             = False
        self._str_returnStore           = ""

        for key,val in kwargs.iteritems():
            if key == 'stateFile':  self._str_stateFile = val
            if key == 'auth':       self.auth           = val
            if key == 'chris':      self.chris          = val
            if key == 'authority':  self.authority      = val

        self.serverInfo                 = serverInfo.serverInfo(authority = self.authority)

        if not self.chris:
            error.fatal(self, 'no_chrisModuleSpec')

        if not len(self._str_stateFile): error.fatal(self, 'no_stateFile')

    def __call__(self, *args, **kwargs):
        '''
        :param args:
        :param kwargs:
        :return:
        '''
        # print("In __call__")
        for key,val in kwargs.iteritems():
            if key == 'APIcall':    self._str_apiCall   = val
        if self._str_apiCall    == "<void>": error.fatal(self, 'no_apiCall')
        # print(self._str_apiCall)
        self.readCallHistory()
        self.parseCurrentCall(authmodule = self.auth)
        return(self.replayCalls())

    def readCallHistory(self):
        """Reads the (parsed) API calls stored in the stateful file.

        Since the ChRIS_SM effectively only executes *one* API
        call before terminating, it needs some mechanism for restoring
        state. This is done by replaying all previous API calls
        pertinent to this session

        If the stateFile does not exist, this method will create an
        empty stateFile.

        Returns:
            state (boolean): True if all previous commands haven been read.
        """

        if not os.path.isfile(self._str_stateFile):
            open(self._str_stateFile, 'a').close()
            return False
        with open(self._str_stateFile) as f:
            self._l_apiCallHistory = f.read().splitlines()
        return True

    def str2URL(self, astr_stringSpec, ab_strip = False):
        """
        Parses the string as if it were a query URL.
        :param astr_stringSpec: input string to parse
        :param ab_strip: If True, strip certain characters from string.
        :return: dictionary of key,val extracted from astr_stringSpec
        """
        str_parametersURL   = '?%s' % astr_stringSpec.replace(',' ,'&')
        d_parametersURL     = parse_qs(urlparse(str_parametersURL).query)
        if 'user' in d_parametersURL.keys():
            self.user   = d_parametersURL['user'][0]
            if ab_strip: self.user   = self.user.translate(None, '\'\"')
        if 'hash' in d_parametersURL.keys():
            self.hash   = d_parametersURL['hash'][0]
            if ab_strip: self.hash   = self.hash.translate(None, '\'\"')
        if 'passwd' in d_parametersURL.keys():
            self.passwd = d_parametersURL['passwd'][0]
            if ab_strip: self.passwd = self.passwd.translate(None, '\'\"')
        return(d_parametersURL)

    def parseCurrentCall(self, **kwargs):
        """Parses the apiCall and updates the stateFile.

        This method parses the <apiCall>, executes it, and updates
        the call to the stateFile, also adding the parsed call to
        the self._l_apiCallHistory list.

        Also parses the authentication.

        Returns:
            state (boolean): True if <apiCall> parsed

        """

        str_auth        = ""
        for key,value in kwargs.iteritems():
            if key == 'authmodule':         auth                    = value

        if not len(auth._name): error.fatal(self, 'no_authModuleSpec')

        # The main URL components
        str_auth        = auth._name
        str_ret         = ""
        str_object      = ""
        str_method      = ""
        str_parameters  = ""

        d_component     = parse_qs(urlparse(self._str_apiCall).query)

        if 'clearSessionFile' in d_component:
            self._b_clearStateFile = int(d_component['clearSessionFile'][0])
        else:
            self._b_clearStateFile = False
        if 'returnstore' in d_component:
            str_ret                 = d_component['returnstore'][0]
            self._b_returnStore     = True
            self._str_returnStore   = str_ret
        else:
            self._b_returnStore     = False
            self._str_returnStore   = "APIreturn"
        if 'object'      in d_component: str_object      = d_component['object'][0]
        str_method                  = d_component['method'][0]
        if 'parameters'  in d_component: str_parameters  = d_component['parameters'][0]
        if str_method == 'login' or str_method == 'logout':
            self.str2URL(str_parameters)
        if len(str_ret):    str_ret     = "%s="   % str_ret
        if len(str_object) and str_method != 'login' and str_method != 'logout':
            str_object  = "%s(lambda: %s."     % (str_auth, str_object)
        if len(str_object) and str_method == 'login' or str_method == 'logout':
            str_object  = '%s.' % str_object

        # Parse the "auth" components
        if 'auth'       in d_component:
            str_authSpec    = d_component['auth'][0]
            self.str2URL(str_authSpec)

        if len(str_parameters):
            str_eval    = "%s%s%s(%s)" % (
                str_ret,
                str_object,
                str_method,
                str_parameters
            )
        else:
            str_eval    = "%s%s%s()" % (
                str_ret,
                str_object,
                str_method
            )

        if len(str_object):
            if str_method != 'login' and str_method != 'logout':
                str_eval += ", user=%s, hash=%s)" % (self.user, self.hash)
        self._l_apiCallHistory.append(str_eval)
        #print(d_component)
        str_mode = 'a'
        # print("clear state file = %d" % self._b_clearStateFile)
        if self._b_clearStateFile: str_mode = 'w'
        with open(self._str_stateFile, str_mode) as f:
            f.write("# %s %s\n" % (datetime.datetime.now(), self._str_apiCall))
            f.write("%s\n" % str_eval)

    def replayCalls(self):
        """Play back calls stored in the internal list buffer.

        Since this effectively just "runs" the python commands in the
        statefile, this should typically execute at the highest level/scope
        of the program, i.e. at the __main__ level!

        The "current" API call is the last entry. All previous entries
        are replayed.

        The last entry is edited so that its return value is captured and
        printed to stdout.

        Preconditions:
            self._l_apiCallHistory is populated.

        Returns:
            state (boolean): The return value of each command as executed
        """

        auth        = self.auth
        chris       = self.auth.chris

        # Play out the previous API calls to restore state up to current call
        for cmd in self._l_apiCallHistory[0:-1]:
            if cmd[0] != "#":
                self.debug("replay cmd: %s\n" % cmd)
                exec(cmd) in locals()


        # Record the actual python call
        cmd             = self._l_apiCallHistory[-1]
        self.d_cmd      = {'pycode': cmd}

        if not self._b_returnStore:
            cmd = "self.d_call = %s" % cmd
        self.debug('this cmd: %s\n' % cmd)
        exec(cmd) in locals()
        if self._b_returnStore:
            exec("self.d_call = %s" % self._str_returnStore)

        return(self.formatReturnJSON())

    def formatReturnJSON(self):
        """

        :return: the formatted JSON components
        """

        d_auth  = self.chris.DB.user_getAuthInfo(user = self.user)
        d_API   = {'APIcall':   self._str_apiCall}

        d_result   = {
            'cmd':      self.d_cmd,
            'auth':     d_auth,
            'API':      d_API,
            'return':   self.d_call,
            'server':   {'URI': self.serverInfo.URI, 'APIversion': self.serverInfo.APIversion}

        }

        return d_result

def JSONdump_all(al_history):
    """
    Prints a fully conformant JSON type object around the l_history
    :param al_history: history of calls
    :return:
    """
    print("{")
    for i in range(0, len(al_history)):
        if not i:
            print(" \"call_%03d\": " % i, end="")
        else:
            print(",\"call_%03d\": " % i, end="")
        print(json.dumps(al_history[i]))
    print("}")

if __name__ == "__main__":

    chris               = ChRIS_SM.ChRIS_SM_RPC(stateFile = 'session.py')   # This also instantiates a chris.API object
    chris.API.auth      = ChRIS_SM.ChRIS_authenticate(chris, 'auth')

    l_callHistory       = []

    l_callHistory.append(
        chris.API(APIcall   = "http://chris_service?returnstore=d&object=chris&method=login&parameters=user='chris',passwd='chris1234'&clearSessionFile=1")
    )

    l_callHistory.append(
        chris.API(APIcall   = "http://chris_service?object=chris.homePage&method=feeds_organize&parameters=schema='default'&auth=user='chris',hash='dabcdef1234'")
    )

    l_callHistory.append(
        chris.API(APIcall   = "http://chris_service?object=chris.homePage&method=feed_getFromObjectName&parameters='Feed-3',returnAsDict=True&auth=user='chris',hash='dabcdef1234'")
    )

    l_callHistory.append(
        chris.API(APIcall   = "http://chris_service?object=chris&method=logout&parameters=user='chris'")
    )


    JSONdump_all(l_callHistory)


