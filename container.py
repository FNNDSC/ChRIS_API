#!/usr/bin/env python

# -*- coding: utf-8 -*-
"""

 _____ _    ______ _____ _____   _   _ _ _
/  __ \ |   | ___ \_   _/  ___| | | | | | |
| /  \/ |__ | |_/ / | | \ `--.  | | | | | |_ _ __ ___  _ __
| |   | '_ \|    /  | |  `--. \ | | | | | __| '__/ _ \| '_ \
| \__/\ | | | |\ \ _| |_/\__/ / | |_| | | |_| | | (_) | | | |
 \____/_| |_\_| \_|\___/\____/   \___/|_|\__|_|  \___/|_| |_|



font generated by:
http://patorjk.com/software/taag/#p=display&f=Doom&t=ChRIS%20Ultron

This module implements a server side container controller/model.

"""

import  abc
import  json
import  sys
import  datetime

import  C_snode
import  message

import  title
import  note
import  comment
import  data
import  plugin


class ContainerTree(object):
    '''
    Implements various operations on a collection (tree) of container objects.

    A container is a collection of regularly organized data that lends itself
    logically to expression as a (directory) tree.
    
    Semantically, container objects are either
    
        'Feeds'
        'Plugins'

    which differ only in their internal records. A 'Plugin' has a set of
    variable inputs on which it performs some aciton, generating essentially
    a dataTree as output. This dataTree is packaged either in a feed (with title,
    note, comments) or connected to a previous dataTree via the plugin.

    A 'Feed' can contain a 'Plugin' tree which in turn can contain other 'Feed'
    trees.
    
    Basically, a 'Plugin' creates a 'Feed' as output. This output 'Feed' can either
    reside at the root level of the user data space, or can be embedded as part of 
    a parent 'Feed' tree.
    
    '''

    def log(self, *args):
        '''
        get/set the internal pipeline log message object.

        Caller can further manipulate the log object with object-specific
        calls.
        '''
        if len(args):
            self._log = args[0]
        else:
            return self._log

    def name(self, *args):
        '''
        get/set the descriptive name text of this object.
        '''
        if len(args):
            self.__name = args[0]
        else:
            return self.__name

    def __init__(self, **kwargs):
        '''Construct a tree -- typically there is one tree per user

        '''
        self._containerTree          = C_snode.C_stree()
        self.container               = C_snode.C_stree()
        self.plugin             = plugin.Plugin_homePage()
        self.debug              = message.Message(logTo = './debug.log')
        self.debug._b_syslog    = True
        self._log               = message.Message()
        self._log._b_syslog     = True
        self.__name             = "FeedTree"

    def container_existObjectName(self, astr_containerObjectName):
        """Check if a container exists.

        Simply checks if a given container with passed containerObjectName exists. The
        containerObjectName is the actual object record name in the snode tree.
        Searching on container object name is much quicker than querying
        each container for its ID.

        Args:
            astr_containerObjectName (string): The Feed Object Name.

        Returns:
            exists (boolean): True if exists, False if not.

        """
        f = self._containerTree
        f.cd('/')
        if f.cd(astr_containerObjectName):
            return True
        else:
            return False

    def container_existObjectID(self, astr_containerID):
        """Check if a container exists.

        Simply checks if a given container with passed ID exists. This method needs
        to loop over all containers and check their internal ID string.

        Args:
            astr_containerID (string): The Feed ID.

        Returns:
            exists (boolean): True if exists, False if not.

        """
        f = self._containerTree
        l_container = f.lstr_lsnode('/')
        for containerNode in f.lstr_lsnode('/'):
            f.cd('/%s' % containerNode)
            str_ID = f.cat('ID')
            if str_ID == astr_containerID:
                return True
        return False

    def container_GETURI(self, **kwargs):
        """
        The list of GET URIs at the current processing scope.
        :param kwargs:
        :return: The list of GET URIs at this scope referenced to current Feed context.
        """

        containerSpec    = ''
        str_path    = '/'
        for key,val in kwargs.iteritems():
            if key == 'containerSpec':   containerSpec    = val
            if key == 'path':       str_path    = val
        # f           = self.container.DB
        f           = self.container
        f.cd(str_path)
        str_path    = f.cwd()
        if str_path == '/': str_path = ''
        l_branch    = f.lstr_lsnode(str_path)
        l_URI       = []
        for node in l_branch:
            l_URI.append('Feeds/%s%s/%s' % (containerSpec, str_path, node))
        # Need to check this conditional?
        if not len(l_branch):
            for terminus in f.lsf(str_path):
                l_URI.append('Feeds/%s%s/%s' % (containerSpec, str_path, terminus))
        return l_URI

    def containers_organize(self, **kwargs):
        """Basically "gets" the container tree, possibly (re)organized according
        to kwargs.

        :param kwargs:
        :return:
        """
        b_returnAsDict  = False
        str_schema      = "default"

        for key,val in kwargs.iteritems():
            if key == "returnAsDict":   b_returnAsDict  = val
            if key == 'schema':         str_schema      = val

        l_keys = []

        # More logic needed here to possibly reorganize
        if str_schema == "default":
            # Generate a list of container elements
            d_tree = dict(self._containerTree.snode_root)
            l_keys = d_tree.keys()

        l_URL = []
        for key in l_keys:
            l_URL.append('Feeds/NAME_%s' % (key))

        return {
            'status':   True,
            'payload':  {'list': l_keys},
            'URL_GET':  l_URL,
            'URL_POST': []
        }

    def container_containerList_fromTreeGet(self, **kwargs):
        """
        Process the main containerTree (i.e. the tree that has all the Feeds.
        :param kwargs: schema='name'|'id' -- how to return the list of Feeds.
        :return: a list of "hits" in URI format
        """
        str_searchType      = 'name'
        d_ret               = {
            'debug':        'container_containerList_fromTreeGet(): ',
            'status':       False,
            'payload':      {},
            'URL_get':      []
        }

        for key,val in kwargs.iteritems():
            if key == 'searchType':     str_searchType      = val
            if key == 'd_ret':          d_ret               = val

        d_ret['debug']  = 'container_containerList_fromTreeGet(): '
        l_URI   = []
        l_keys  = []

        F           = self._containerTree
        if F.cd('/containers')['status']:
            if str_searchType.lower() == "name":
                # Generate a list of container elements
                l_keys          = F.lstr_lsnode()
                l_URI           = ['Feeds/NAME_' + name for name in l_keys]
                d_ret['status'] = True
            if str_searchType.lower() == 'id':
                for containerNode in F.lstr_lsnode():
                    F.cd('/containers/%s' % containerNode)
                    str_ID = F.cat('ID')
                    l_keys.append(str_ID)
                    l_URI.append('Feeds/ID_' + str_ID)
                d_ret['status'] = True
        d_ret['payload']    = l_keys
        d_ret['URL_get']    = l_URI

        return d_ret

    def container_singleFeed_fromTreeGet(self, **kwargs):
        '''
        Graft a single target container from the container tree to internal storage.

        This basically just "links" the container to be processed to a convenience
        variable.

        :return:
        d_ret:      dictionary      various values
        '''

        # Initialize the d_ret return dictionary
        d_ret           = {
            'container':         None,
            'status':       False,
            'payload':      {},
            'URL_get':      []
        }

        for key,val in kwargs.iteritems():
            if key == 'searchType':     str_searchType      = val
            if key == 'searchTarget':   str_searchTarget    = val
            if key == 'schema':         str_schema          = val
            if key == 'd_ret':          d_ret               = val

        d_ret['debug']  = 'container_fromFeedTree_get():'
        F               = self._containerTree
        F.cd('/containers')

        self.container   = C_snode.C_stree()
        s           = self.container
        if str_searchType.lower() == 'name':
            if F.cd(str_searchTarget)['status']:
                Froot = F.cwd()
                # s.graft(F, '%s/'      % F.cwd())
                s.graft(F, '%s/title'   % Froot)
                s.graft(F, '%s/note'    % Froot)
                s.graft(F, '%s/data'    % Froot)
                s.graft(F, '%s/comment' % Froot)
                d_ret['status'] = True
                d_ret['container']   = s
                s.tree_metaData_print(False)
        if str_searchType.lower() == 'id':
            for containerNode in f.lstr_lsnode('/'):
                if F.cd('/containers/%s' % containerNode)['status']:
                    if str_searchTarget == F.cat('ID'):
                        d_ret['status'] = True
                        # s.graft(F, '%s/'      % F.cwd())
                        s.graft(F, '%s/title'   % Froot)
                        s.graft(F, '%s/note'    % Froot)
                        s.graft(F, '%s/data'    % Froot)
                        s.graft(F, '%s/comment' % Froot)
                        d_ret['container']   = s
                        break
        return d_ret

    def container_singleFeed_process(self, **kwargs):
        '''
        Assuming a container has been grafted from the tree space, process this
        container's components.

        :return:
        '''

        d_ret               = {
            'container':         None,
            'debug':        'container_singleFeed_process(): ',
            'path':         '',
            'status':       False,
            'payload':      {},
            'URL_get':      []
        }

        for key,val in kwargs.iteritems():
            if key == 'VERB':           str_VERB            = val
            if key == 'pathInFeed':     str_pathInFeed      = val
            if key == 'd_ret':          d_ret               = val

        d_ret['b_returnTree']   = True
        d_ret['debug']         += 'str_pathInFeed = %s ' % str_pathInFeed
        s                       = d_ret['container']
        d_cd                    = s.cd(str_pathInFeed)
        if d_cd['status']:
            # We are retrieving a directory
            d_ret['status']     = d_cd['status']
            d_ret['pathInFeed'] = d_cd['path']
            subTree             = C_snode.C_stree()
            if subTree.cd('/')['status']:
                subTree.graft(s, str_pathInFeed)
                d_ret['container']   = subTree
        else:
            d_ret['b_returnTree']   = False
            # Check if we are in fact processing a "file"
            l_p                     = str_pathInFeed.split('/')
            str_dirUp               = '/'.join(l_p[0:-1])
            d_cd                    = s.cd(str_dirUp)
            if d_cd['status']:
                d_ret['debug']     += '../ = %s, file = %s' % (str_dirUp, l_p[-1])
                d_ret['status']     = d_cd['status']
                d_ret['pathInFeed'] = d_cd['path']
                str_fileName        = l_p[-1]
                if str_VERB != "GET":
                    self.container_singleFeed_VERBprocess(**kwargs)
                    self.debug('%s\n' % l_p)
                contents            = s.cat(l_p[-1])
                if not contents:
                    d_ret['container']   = {str_fileName: ''}
                else:
                    d_ret['container']   = {str_fileName: contents}
                self.debug('Returning file contents in payload: "%s"\n' % d_ret)
        d_ret['payload'] = d_ret['container']
        return d_ret

    # This method is the only point of contact between the simulated machine and the internal
    # data space and the external REST call.
    def container_singleFeed_VERBprocess(self, **kwargs):
        '''
        Process specific cases of REST VERBS

        :return:
        '''

        d_ret   = {
            'debug':    'container_singleFeed_VERBprocess(): '
        }

        for key,val in kwargs.iteritems():
            if key == 'd_ret':          d_ret               = val

        # This signals the client to 'refresh' the display since POST operations
        # change GUI elements
        d_ret['refreshREST']    = True

        if d_ret['VERB'] == 'POST':
            self.debug('In container_singleFeed_VERBprocess...\n')
            with open(d_ret['payloadFile']) as jf:
                d_payload   = json.load(jf)
                self.debug('Payload: %s\n' % d_payload)
                s = d_ret['container']
                self.debug('location in container tree: %s\n' % s.pwd() )
                action      = d_payload['POST']['action']

                # find the 'object' key (i.e. the key other than 'action')
                for key in d_payload['POST'].keys():
                    if key != 'action':
                        str_nodeType = key
                str_nodeName    = d_payload['POST'][str_nodeType].keys()[0]
                str_contents    = d_payload['POST'][str_nodeType][str_nodeName]

                if action == 'post' and str_nodeType == 'file':
                    self.debug('Pushing text contents into file %s\n' % str_nodeName)
                    s.touch(str_nodeName,  str_contents)

                if action == 'del':
                    self.debug('Deleting object %s\n' % str_nodeName)
                    self.debug('path in stree: %s\n' % s.pwd())
                    s.rm(str_nodeName)

                if action == 'clear':
                    self.debug('clearing object %s\n' % str_nodeName)
                    self.debug('path in stree: %s\n' % s.pwd())
                    s.touch(str_nodeName, '')

                if action == 'run':
                    self.debug('Regenerating node %s\n' % str_nodeName)
                    # Generate a new container tree -- this following call generates
                    # everything for a new container! notes, title, comments, etc.
                    # It's probably overkill.
                    str_timeStamp   = str(datetime.datetime.now())
                    if str_nodeName != 'timestamp':
                        s_regen         = Feed_FS()
                        sr              = s_regen._stree
                        if s.pwd() == '/title'  or s.pwd == '/title/body':
                            self.debug('Regenerating title...\n')
                            sr.cd('/title')
                            s.cd('/title')
                            s.rm('body')
                            s.touch('body', sr.cat('body'))
                        if s.pwd() == '/note'   or s.pwd == '/note/body':
                            self.debug('Regenerating note...\n')
                            sr.cd('/note')
                            s.cd('/note')
                            s.rm('body')
                            s.touch('body', sr.cat('body'))
                    self.debug('setting timeStamp to %s\n' % str_timeStamp)
                    s.touch('timestamp', str_timeStamp)

    def container_process(self, **kwargs):
        """
        Get a container based on various criteria
        :param kwargs: searchType = 'name' | 'id', target = <target>
        :return: Feed conforming to search criteria
        """
        b_returnAsDict      = True

        str_searchType      = ''
        str_searchTarget    = ''
        str_pathInFeed      = ''

        d_ret               = {
            'VERB':             'GET',
            'payloadFile':      '',
            'container':             None,
            'debug':            'container_process(): ',
            'path':             '',
            'pathInFeed':       '',
            'b_status':         False,
            'payload':          {},
            'URL_get':          [],
            'b_returnTree':     True
        }

        for key,val in kwargs.iteritems():
            if key == 'VERB':           d_ret['VERB']           = val
            if key == 'payloadFile':    d_ret['payloadFile']    = val
            if key == 'returnAsDict':   b_returnAsDict          = val
            if key == 'searchType':     str_searchType          = val
            if key == 'searchTarget':   str_searchTarget        = val
            if key == 'pathInFeed':     str_pathInFeed          = val
            if key == 'schema':         str_schema              = val

        kwargs['d_ret'] = d_ret

        # First get the container itself from the tree of Feeds...
        F               = self._containerTree
        F.cd('/containers')
        str_containerSpec    = '%s_%s' % (str_searchType.upper(), str_searchTarget)

        # Check if we want a list of all containers for this user
        if not len(str_searchType) or not len(str_searchTarget) or str_searchTarget == '*':
            d_ret           = self.container_containerList_fromTreeGet(**kwargs)
            d_ret['debug'] += "Search for '%s' on type '%s'" % (str_searchTarget, str_searchType)
        else:
            # Or if we just want one specific container
            d_ret       = self.container_singleFeed_fromTreeGet(**kwargs)

            # and now, check for any paths in the tree of this Feed
            if len(str_pathInFeed) and str_pathInFeed != '/':
                self.debug('Path in Feed: %s\n' % str_pathInFeed)
                d_ret           = self.container_singleFeed_process(**kwargs)

            # b_returnTree is always True, unless a "file" is being returned
            if b_returnAsDict and d_ret['b_returnTree']:
                d_ret['container']   = dict(d_ret['container'].snode_root)
            d_ret['payload']    = d_ret['container']
            d_ret['URL_get']    = self.container_GETURI(containerSpec = str_containerSpec, path = str_pathInFeed)

        # Pop the "temp" key 'container' from the return stack
        if 'container' in d_ret: d_ret.pop('container')

        # Set the 'path'
        d_ret['path']   = str_searchTarget + str_pathInFeed
        return d_ret


class FeedTree_chrisUser(FeedTree):
    '''
    A Feed Tree for a hypothetical user on the ChRIS system. Each user will
    have identical trees under this scenario.
    '''

    def __init__(self, **kwargs):
        '''
        Build the tree.

        :return:
        '''
        FeedTree.__init__(self, **kwargs)
        F       = self._containerTree
        l_Feed  = ['Feed-1', 'Feed-2', 'Feed-3', 'Feed-4']
        l_FID   = ['000001', '000002', '000003', '000004']
        F.cd('/')
        F.mkcd('containers')
        F.mknode(l_Feed)
        for node, id in zip(l_Feed, l_FID):
            F.cd('/containers/%s' % node)
            F.touch("ID", id)
            # self.debug(f)
            singleFeed  = Feed_FS(
                name    = node,
                id      = id
            )
            s = singleFeed._stree
            # Graft explicit parts of this singleFeed (s) to the tree of
            # all Feeds (F) of this user, i.e.
            #   cd F:/containers/Feed-<ID>
            #   ln -s s:/note .
            #   ln -s s:/title .
            #       ... etc ...
            F.graft(s, '/note')
            F.graft(s, '/title')
            F.graft(s, '/comment')
            F.graft(s, '/data')
        F.cd('/containers')
        F.tree_metaData_print(False)
        # self.debug(F)

if __name__ == "__main__":
    container    = Feed_FS()
    T       = FeedTree_chrisUser()
    print(T._containerTree.snode_root)

    print(T.plugin.getList())
    print(T.plugin.set('file_browser'))
    print(T.plugin.run())
