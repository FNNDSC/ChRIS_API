#!/usr/bin/env python

# -*- coding: utf-8 -*-
"""

 _____ _    ______ _____ _____   _   _ _ _
/  __ \ |   | ___ \_   _/  ___| | | | | | |
| /  \/ |__ | |_/ / | | \ `--.  | | | | | |_ _ __ ___  _ __
| |   | '_ \|    /  | |  `--. \ | | | | | __| '__/ _ \| '_ \
| \__/\ | | | |\ \ _| |_/\__/ / | |_| | | |_| | | (_) | | | |
 \____/_| |_\_| \_|\___/\____/   \___/|_|\__|_|  \___/|_| |_|



font generated by:
http://patorjk.com/software/taag/#p=display&f=Doom&t=ChRIS%20Ultron
"""

from __future__ import print_function

str_desc = """




 _____ _    ______ _____ _____ ______ _____ _____ _____ ___  ______ _____
/  __ \ |   | ___ \_   _/  ___|| ___ \  ___/  ___|_   _/ _ \ | ___ \_   _|
| /  \/ |__ | |_/ / | | \ `--. | |_/ / |__ \ `--.  | |/ /_\ \| |_/ / | |
| |   | '_ \|    /  | |  `--. \|    /|  __| `--. \ | ||  _  ||  __/  | |
| \__/\ | | | |\ \ _| |_/\__/ /| |\ \| |___/\__/ / | || | | || |    _| |_
 \____/_| |_\_| \_|\___/\____/ \_| \_\____/\____/  \_/\_| |_/\_|    \___/
                           ______
                          |______|



'ChRIS_RESTAPI' -- ChRIS GET handler -- processes the GET requests from
an external client.

This class/module is responsible for mapping the GET formated REST requests
to actual ChRIS calls.

Furthermore, this class demonstrates how to call the underlying API, modules
and classes directly (as opposed to a system call to ChRIS_SM -- see
ChRIS_client).

"""

from    webob           import Response
from    urlparse        import urlparse, parse_qs

import  message
import  error
import  ChRIS_SM
import  serverInfo
import  json

import  crun
import  SocketServer
import  argparse
import  os
import  sys
import  datetime

class ChRIS_RESTAPI(object):
    """This class processes GET verbs. Effectively it maps from the REST API
        to actual object.method calls."""

    #
    # Class member variables -- if declared here are shared
    # across all instances of this class
    #
    _dictErr = {
        'no_apiCall'   : {
            'action'        : 'examining command line arguemnts, ',
            'error'         : 'it seems that the required --apiCall is missing.',
            'exitCode'      : 11},
        'no_authModuleSpec' : {
            'action'        : 'executing API call, ',
            'error'         : "there doesn't seem to be an auth module!",
            'exitCode'      : 12},
        'no_chrisModuleSpec' : {
            'action'        : 'building API object, ',
            'error'         : "the reference to the containing <chris> object is missing!",
            'exitCode'      : 13},
        'malformedURL' : {
            'action'        : 'parsing REST call, ',
            'error'         : "the URL itself didn't yield a path -- it might be malformed. Perhaps an extra '?'",
            'exitCode'      : 14}
    }

    def log(self, *args):
        '''
        get/set the internal pipeline log message object.

        Caller can further manipulate the log object with object-specific
        calls.
        '''
        if len(args):
            self._log = args[0]
        else:
            return self._log

    def name(self, *args):
        '''
        get/set the descriptive name text of this object.
        '''
        if len(args):
            self.__name = args[0]
        else:
            return self.__name

    def __init__(self, *args, **kwargs):

        # auth is the per-call authentication module
        self.auth                       = None
        # chris is the chris-object that contains this API
        self.chris                      = None

        self._str_apiCall               = ""
        self.debug                      = message.Message(logTo = './debug.log')
        self.debug._b_syslog            = True
        self._log                       = message.Message()
        self._log._b_syslog             = True
        self.__name                     = "ChRIS_RESTAPI"

        self.str_APIaction              = "GET" # GET or PUT

        self.user                       = ""
        self.hash                       = ""
        self.passwd                     = ""
        self.authority                  = "localhost:5555"

        # JSON return objects
        self.d_return                   = {}
        self.d_call                     = {}
        self.d_auth                     = {}
        self.d_API                      = {}


        for key,val in kwargs.iteritems():
            if key == 'auth':       self.auth           = val
            if key == 'chris':      self.chris          = val
            if key == 'authority':  self.authority      = val

        self.serverInfo                 = serverInfo.serverInfo(authority = self.authority)

        if not self.chris:
            error.fatal(self, 'no_chrisModuleSpec')

    def __call__(self, *args, **kwargs):
        '''
        :param args:
        :param kwargs:
        :return:
        '''
        # print("In __call__")
        for key,val in kwargs.iteritems():
            if key == 'APIcall':    self._str_apiCall   = val
        if self._str_apiCall    == "<void>": error.fatal(self, 'no_apiCall')
        # print(self._str_apiCall)
        self.d_return = self.parseCurrentCall(authmodule = self.auth)
        return(self.d_return)

    def parseCurrentCall(self, **kwargs):
        """Parse the current REST call"""

        for key,value in kwargs.iteritems():
            if key == 'authmodule':         auth                    = value

        try:
            if not len(auth._name): error.fatal(self, 'no_authModuleSpec')
        except:
            error.fatal(self, 'no_authModuleSpec')

        URL_parts       = urlparse(self._str_apiCall)
        l_path          = URL_parts.path.split('/')[2:]     # skip the /vX/!
        d_query         = parse_qs(URL_parts.query)

        if not len(l_path):
            error.fatal(self, 'malformedURL', 'URL: %s' % self._str_apiCall)

        # print(l_path)
        # print(d_query)

        if 'auth' in d_query:
            str_authSpec    = d_query['auth'][0]
            str_authURL     = "?%s" % str_authSpec.replace(',', '&')
            d_auth          = parse_qs(urlparse(str_authURL).query)
            # print(d_auth.keys())
            if 'user' in d_auth.keys():
                self.user   = d_auth['user'][0]
            if 'hash' in d_auth.keys():
                self.hash   = d_auth['hash'][0]
            if 'passwd' in d_auth.keys():
                self.passwd = d_auth['passwd'][0]

        self.parsePathSpec(l_path)
        return(self.formatReturnJSON())

    def parseLogin(self):
        """
        Parse the REST login
        :return:
        """
        self.d_call = self.chris.DB.user_login(user = self.user, passwd = self.passwd)

    def parseLogout(self):
        """
        Parse the REST login
        :return:
        """
        self.d_call = self.chris.DB.user_logout(user = self.user)

    def parsePathSpec(self, al_path):
        """
        The main decision "nexus" to parse an incoming API request.

        :param al_path: the path list spec
        :return:
        """

        # print(al_path)
        # print(len(al_path))

        # login...
        if al_path[0].lower() == 'login':
            self.parseLogin()
            return True

        # logout...
        if al_path[0].lower() == 'logout':
            self.parseLogout()
            return True

        # GET a Feed or internals of a Feed...
        if len(al_path) and self.str_APIaction == "GET":
            if len(al_path) == 1:
                # GET a list of all Feeds
                self.d_call     = self.auth(lambda: self.chris.homePage.feeds_organize(
                                        schema          = 'default'),
                                        user            = self.user,
                                        hash            = self.hash)

            str_path            = ''
            if len(al_path) >= 2:
                str_path        = '/'.join(al_path[2:])
                str_feedTarget  = al_path[1]
                l_targetType    = str_feedTarget.split('_')
                self.d_call     = self.auth(lambda: self.chris.homePage.feed_get(
                                        searchType      = l_targetType[0].lower(),
                                        target          = l_targetType[1],
                                        returnAsDict    = True,
                                        pathInFeed      = str_path),
                                        user            = self.user,
                                        hash            = self.hash)


            # if len(al_path) == 2:
            #     # GET a single feed tree
            #     str_feedTarget  = al_path[1]
            #     l_targetType    = str_feedTarget.split('_')
            #     self.d_call     = self.auth(lambda: self.chris.homePage.feed_get(
            #                             searchType      = l_targetType[0].lower(),
            #                             target          = l_targetType[1],
            #                             returnAsDict    = True),
            #                             user            = self.user,
            #                             hash            = self.hash)
            # if len(al_path) == 3:
            #     # GET a component of a specified feed tree
            #     # First GET the spec'd feed...
            #     str_feedTarget  = al_path[1]
            #     l_targetType    = str_feedTarget.split('_')
            #     d_feed          = self.auth(lambda: self.chris.homePage.feed_get(
            #                             searchType      = l_targetType[0].lower(),
            #                             target          = l_targetType[1],
            #                             returnAsDict    = True),
            #                             user            = self.user,
            #                             hash            = self.hash)
            #     # and now the part of the feed we want
            #     str_component   = al_path[2]
            #     self.d_call     = {
            #                     'status':   True,
            #                     'payload':  d_feed['payload']['Feed'][str_component]
            #                     }
            #
            # if len(al_path) > 3:
            #     # GET a component of a specified feed tree
            #     # First GET the spec'd feed...
            #     str_feedSpec    = '%s_%s' % (l_targetType[0].upper(), l_targetType[1])
            #     str_feedTarget  = al_path[1]
            #     l_targetType    = str_feedTarget.split('_')
            #     d_feed          = self.auth(lambda: self.chris.homePage.feed_get(
            #                             searchType      = l_targetType[0].lower(),
            #                             target          = l_targetType[1],
            #                             returnAsDict    = False),
            #                             user            = self.user,
            #                             hash            = self.hash)
            #     s = d_feed['payload']._stree
            #     s.cd('/')
            #     for depth in range(2, len(al_path)):
            #         s.cd(al_path[depth])
            #         str_path    = s.cwd()
            #     self.d_call     = {
            #                     'status':   True,
            #                     'payload':  dict(s.snode_current),
            #                     'URL_get':  self.auth(lambda: self.chris.homePage.feed_GETURI(
            #                             feed            = d_feed,
            #                             feedSpec        = str_feedSpec,
            #                             path            = str_path),
            #                             user            = self.user,
            #                             hash            = self.hash)
            #                     }
        return True


    def formatReturnJSON(self):
        """

        :return: the formatted JSON components
        """

        d_auth  = self.chris.DB.user_getAuthInfo(user = self.user)
        d_API   = {'APIcall':   self._str_apiCall}

        d_result   = {
            'auth':     d_auth,
            'API':      d_API,
            'return':   self.d_call,
            'server':   {'URI': self.serverInfo.URI, 'APIversion': self.serverInfo.APIversion}
        }

        return d_result

def JSONdump_all(al_history):
    """
    Prints a fully conformant JSON type object around the l_history
    :param al_history: history of calls
    :return:
    """
    print("{")
    for i in range(0, len(al_history)):
        if not i:
            print(" \"call_%03d\": " % i, end="")
        else:
            print(",\"call_%03d\": " % i, end="")
        print(json.dumps(al_history[i]))
    print("}")

if __name__ == "__main__":

    chris               = ChRIS_SM.ChRIS_SM_REST()   # This also instantiates a chris.API object
    chris.API.auth      = ChRIS_SM.ChRIS_authenticate(chris, 'auth')

    l_callHistory       = []

    l_callHistory.append(
        chris.API(APIcall   = "/v1/login?auth=user=chris,passwd=chris1234")
    )

    l_callHistory.append(
        chris.API(APIcall   = "/v1/Feeds?auth=user=chris,hash=123456")
    )

    l_callHistory.append(
        chris.API(APIcall   = "/v1/Feeds/NAME_Feed-1?auth=user=chris,hash=123456")
    )

    l_callHistory.append(
        chris.API(APIcall   = "/v1/logout?auth=user=chris")
    )


    JSONdump_all(l_callHistory)